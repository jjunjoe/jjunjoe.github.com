<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Joe’s Home]]></title>
  <link href="http://jjunjoe.github.io/atom.xml" rel="self"/>
  <link href="http://jjunjoe.github.io/"/>
  <updated>2016-01-15T22:42:05+08:00</updated>
  <id>http://jjunjoe.github.io/</id>
  <author>
    <name><![CDATA[Joe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 开发随笔记录]]></title>
    <link href="http://jjunjoe.github.io/blog/2014/07/09/ios-kai-fa-sui-bi-ji-lu/"/>
    <updated>2014-07-09T22:43:04+08:00</updated>
    <id>http://jjunjoe.github.io/blog/2014/07/09/ios-kai-fa-sui-bi-ji-lu</id>
    <content type="html"><![CDATA[<h1>说明</h1>

<p>本文是我的 iOS 随笔记录，来源于我自己碰到的问题，也有看到的别人遇到的问题记录。本文会随时更新，逐渐增加&hellip;&hellip;</p>

<!--more-->


<h1>随笔记录</h1>

<h2>1、在 ARC 下，IBOutlets 到底应该定义成 strong 还是 weak ？</h2>

<p><code>答案</code>：</p>

<p>在 ARC 中,一般 outlet 属性都推荐使用 weak。<br/>
nib 的 File&rsquo;s Owner 连接到顶层对象的 outlet，应该使用 strong。</p>

<p>nib 的 File&rsquo;s Owner 连接到顶层对象的 outlet：就是除 main view 里面的其他对象的 outlet。每个 nib 文件在 XCode 中打开后，左边有个列表，列表中几乎都有一个 UIView，它就是顶层对象，跟它平级的其他对象也是顶层对象。比如导航栏中的按钮 UIBarButtonItem。</p>

<p>UIViewController 的 view 属性是 strong，因为 UIViewController 要直接拥有 view。而添加到view 上的 subviews IBOutlet 为 weak，因为他们不是 UIViewController 直接拥有的，直接拥有 subviews 的是 UIViewController 的 view，ARC 会帮助管理内存。</p>

<p>参考苹果官方文档：
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW8">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW8</a></p>

<p>里面有如下描述：</p>

<blockquote><p>From a practical perspective, in iOS and OS X outlets should be defined as declared properties. Outlets should generally be weak, except for those from File’s Owner to top-level objects in a nib file (or, in iOS, a storyboard scene) which should be strong. Outlets that you create should therefore typically be weak, because:<br/>
* Outlets that you create to subviews of a view controller’s view or a window controller’s window, for example, are arbitrary references between objects that do not imply ownership.<br/>
* The strong outlets are frequently specified by framework classes (for example, UIViewController’s view outlet, or NSWindowController’s window outlet).</p></blockquote>

<pre><code>@property (weak) IBOutlet MyView *viewContainerSubview;
@property (strong) IBOutlet MyOtherClass *topLevelObject;  
</code></pre>

<p>还有：<br/>
<a href="http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc">http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Bluetooth Programming Guide 中文翻译]]></title>
    <link href="http://jjunjoe.github.io/blog/2014/07/02/core-bluetooth-programming-guide/"/>
    <updated>2014-07-02T20:43:57+08:00</updated>
    <id>http://jjunjoe.github.io/blog/2014/07/02/core-bluetooth-programming-guide</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>本文是苹果《Core Bluetooth Programming Guide》的翻译。</p>

<h2>关于Core Bluetooth</h2>

<p>Core Bluetooth 框架提供了蓝牙低功耗无线设备与 iOS 应用或 Mac 应用通讯的必要的类。应用可以发现，探索低功耗外设，并与它交互，比如心率监控器和数字温度调节器。<code>从 OS X V10.9 和 iOS 6 之后，Mac 和 iOS 设备也能充当蓝牙低功耗外设给包括 Mac 和 iOS 在内的其他设备提供数据服务了。</code></p>

<p><img src="http://jjunjoe.github.io/images/apple/corebluetooth/figure0-1.png" alt="" /></p>

<!--more-->


<h3>概览</h3>

<p>蓝牙低功耗无线技术（BLE）基于蓝牙4.0规范，在其基础上定义了大量低功耗设备之间通信的协议。Core Bluetooth 框架是蓝牙低功耗协议栈的抽象。也就是说，它对开发者隐藏了规范底层的许多细节，使得你开发与蓝牙低功耗设备通讯的应用变得容易。</p>

<h4>主机（Central）和外设（Peripheral）是 Core Bluetooth 的关键角色</h4>

<p>在蓝药低功耗通讯中，有两个关键的角色：<code>主机</code>和<code>外设</code>。一个典型的外设拥有其他设备需要的数据。一个典型的主机使用外设提供的信息完成某些任务。例如，BLE数字温度调节器可以提供室内温度给一个 iOS 应用，然后应用将温度用用户友好的方式展现出来。  <br/>
外设在空气中广播数据。而主机可以扫描拥有它感兴趣的数据的外设。当主机发现这样的外设时，主机可以请求连接该外设然后探索和交互。然后外设以主机期望的方式响应主机的请求。</p>

<p>  #### Core Bluetooth 简化了通用的蓝牙任务<br/>
Core Bluetooth 框架抽象了蓝牙4.0规范的底层细节。这样应用中需要完成的许多常用的 BLE 任务都变得很简单了。如果你开发的应用是完成蓝牙主机功能，Core Bluetooth 让它很容易发现和与外设连接，容易探索外设和与外设交互。另外，Core Bluetooth 让你很容易使用本地设备来充当外设。</p>

<h4>iOS 应用状态影响蓝牙行为</h4>

<p>当 iOS 应用处于后台或者挂起状态，与蓝牙相关的功能会受到影响。默认情况下，应用在后台或者挂起状态下不能完成 BLE 任务。如果你的应用需要在后台完成 BLE 任务，你需要声明一个或者全部两个 Core Bluetooth 应用的执行模式（一个是主机，一个是外设）。即使你声明了他们的执行模式，但是当应用在后台时，某些特定的蓝牙任务操作还是会与前台有所区别。在设计应用时需要注意这些差别。   <br/>
支持后台处理的应用可能在任何时候被系统终止然后释放内存。自 iOS 7,Core Bluetooth 支持保存主机和外设管理的对象，也支持在应用重启时恢复状态。你可以使用这个特性来支持必要的长期蓝牙设备任务。</p>

<h4>按照最佳实践加强用户体验</h4>

<p>Core Bluetooth 框架让你控制许多通用的 BLE 传输。你需要按照最佳实践负责任的完成这个层级的控制，增强用户体验。<br/>
例如，许多任务需要使用设备无线电来发射信号，而设备无线电是与其他形式的无线通讯共享的，并且无线电使用对电池的使用寿命有很大的影响，所以设计应用时要尽量减少对无线电的使用。</p>

<h4>How to Use This Document</h4>

<p>未翻译。</p>

<h4>See Also</h4>

<p>未翻译。</p>

<h1>Core Bluetooth 概览</h1>

<p>Core Bluetooth 框架让你的 iOS 和 Mac 应用与 BLE 设备通信。例如，你的应用发现，探索，并与 BLE 设备通信（心率监控器，数字温度调节器，甚至其他 iOS 设备）。  <br/>
Core Bluetooth 框架是对使用低功耗设备的蓝牙4.0规范的抽象。也就是说，它影藏了许多底层细节，开发者使用框架可以更容易的开发与 BLE 交互的应用。因为框架基于蓝牙4.0规范，所以采用了规范的一些原则和术语。本章介绍关键的术语和原则，这些都是你使用 Core Bluetooth 开发应用时必须清楚的。</p>

<h2>主机和外设以及他们在蓝牙通信中扮演的角色</h2>

<p>在所有的 BLE 通信中有两个主要的概念：<code>主机</code>和<code>外设</code>。基于一些传统的CS体系，<code>外设</code>典型的<code>拥有其他设备需要的数据</code>。<code>主机</code>典型的<code>使用外设提供的信息来完成特定的任务</code>。如图 1-1 所示，一个心率监控器有些有用的信息，你的 Mac 或 iOS 应用需要这些数据然后将它们友好的展现给用户。</p>

<p><img src="http://jjunjoe.github.io/images/apple/corebluetooth/figure1-1.png" alt="" /></p>

<h3>主机发现和连接发广播的外设</h3>

<p>外设向外广播一些广播包形式的数据。<code>广播包</code>是外设提供的包含有用信息的一束数据，例如外设的名称和主要功能。举个例子，数字温度调节器可以广播当前室温。在 BLE，广播是外设被感知存在的主要方式。  <br/>
主机能够扫描，侦听任何它感兴趣的正在广播的外设。如图 1-2 所示，主机能够请求连接它发现的外设。</p>

<p><img src="http://jjunjoe.github.io/images/apple/corebluetooth/figure1-2.png" alt="" /></p>

<h3>外设的数据如何组织</h3>

<p>连接外设的目的是为了探索外设并与外设交互数据。在做这个之前，有必要理解外设的数据是怎么组织的。  <br/>
外设可以包含一个或者多个服务来提供连接信号强度相关的有用的信息。<code>服务</code>是<code>设备完成某功能相关的数据集合或者设备某特征数据的集合</code>。例如，心率监控器可以展示来自心率传感器的心率数据。<code>服务</code>由<code>特征（characteristics）</code>或者<code>其他服务</code>组成。<code>特征</code>提供外设服务的进一步详情。例如，心率服务可能仅仅包含一个描述心率传感器预定位置的特征和另外一个发送心率测量数据的特征。图 1-3 列出了心率监控器服务和特征的数据结构。</p>

<p><img src="http://jjunjoe.github.io/images/apple/corebluetooth/figure1-3.png" alt="" /></p>

<h3>主机探索外设与外设交互数据</h3>

<p>在主机成功与外设建立连接之后，主机可以找出外设提供的全方位的服务和特性（而广播数据可能只包含部分可用的服务）。  <br/>
主机也可以通过读写服务的特征值来与外设交互。例如，应用可以向数字温度调节器请求当前室温，或者提供一个值让温度调节器设定室温。</p>

<h2>如何描述主机，外设，外设数据</h2>

<p>在 Core Bluetooth 框架中，BLE 的主要参与者和数据都被映射得简单而轻量。</p>

<h3>主机端相关对象</h3>

<p>使用本地主机与远程外设通信时，你在主机端完成操作。除非你设置一个本地外设，然后使用它响应主机的请求，否则大多数蓝牙传输发生在主机这一端。</p>

<h4>本地主机和远程外设</h4>

<p>在主机端，本地主机设备用 <code>CBCentralManager</code> 对象表示。这些对象用来管理发现或连接远程外设（远程外设用 <code>CBPeripheral</code> 对象表示），包括扫描，发现，连接发广播的外设。图 1-4 显示了 Core Bluetooth 框架中本地主机和远程外设如何表示。</p>

<p><img src="http://jjunjoe.github.io/images/apple/corebluetooth/figure1-4.png" alt="" /></p>

<h4>远程外设的数据用 CBService 和 CBCharacteristic 对象表示</h4>

<p>当你与远程外设交互数据的时候，实际上是处理它的服务和特征。在 Core Bluetooth 框架中，远程外设的服务用 CBservice 对象表示。类似的，远程外设的特征用 CBCharacteristic 对象表示。 图 1-5 阐明了远程外设的基服务和特征的基本结构。</p>

<p><img src="http://jjunjoe.github.io/images/apple/corebluetooth/figure1-5.png" alt="" /></p>

<h3>外设方相关对象</h3>

<p>自 OS X v10.9 和 iOS 6，Mac 和 iOS 设备（包括Mac，iPhone，iPad）能够提供 BLE 外设功能，给其他设备提供服务数据。设置你的设备充当外设的角色时，你要完成 BLE 通信中外设那一侧的功能行为。</p>

<h4>本地外设和远程主机</h4>

<p>在外设一侧，本地外设用 CBPeripheralManager 对象表示。这些对象用来管理发布本地外设服务和特征数据库中的服务，广播到远程主机设备（用 CBCentral 对象表示）。外设管理对象也用来响应远程主机的读写请求。图 1-6 显示了本地外设和远程主机在 Core Bluetooth 中的表示。</p>

<p><img src="http://jjunjoe.github.io/images/apple/corebluetooth/figure1-6.png" alt="" /></p>

<h4>本地外设数据用 CBMutableService 和 CBMutableCharacteristic 对象表示</h4>

<p>设置一个本地外设并与它交互数据时，你需要处理本地外设的多个服务和特征的版本。在 Core Bluetooth 框架，本地外设的服务用 CBMutableService 对象表示。类似的，本地外设的特征用 CBMuableCharacteristic 对象表示。 图 1-7 阐明了本地外设服务和特征的基本机构。</p>

<p><img src="http://jjunjoe.github.io/images/apple/corebluetooth/figure1-7.png" alt="" /></p>

<h1>主机通常要完成的任务</h1>

<p>BLE 中扮演主机角色的设备要完成大量通用的任务&ndash;例如，发现和连接可以用的外设，探索外设，与外设交互数据。相对而言，扮演外设的角色也需要完成一些与主机不同的通用的任务，例如发布和广播服务，响应读写数据，处理已连接的主机的请求。  <br/>
本章将学习如何使用 Core Bluetooth 完成 BLE 主机端的通用任务。基于代码的示例可以帮助你用本地设备扮演主机的角色。具体来说你可以学习到：</p>

<ul>
<li>启动主机管理对象</li>
<li>发现和连接广播的外设</li>
<li>连接之后探索外设数据</li>
<li>给外设服务的一些特征值发送读写请求</li>
<li>订阅特征值并在他们更新时得到通知</li>
</ul>


<p>下一章将会学习如何用本地设备扮演外设角色。  <br/>
本章的示例代码简单而抽象，在你实际的应用中需要对其做适当的修改来完善。许多跟主机相关的高级主题会再后面的章节讲述。</p>

<h2>启动主机管理</h2>

<p>CBCentralManager 对象时本地主机设备面向对象的表示，完成 BLE 传输前需要分配和初始化一个主机管理实例。你可以通过调用CBCentralManager类的 initWithDelegate:queue:options: 方法初始化主机管理对象，如下所示：</p>

<pre><code>myCentralManager =    [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil];  
</code></pre>

<p>在这个例子中，self 被设置为接收任何主机事件的委托。通过指定 dispatch queue 为 nil，主机管理对象会用 main queue 主队列分发主机事件。   <br/>
当你创建一个主机管理对象，它会调用它委托的 centralManagerDidUpdateState: 方法。你需要实现改委托方法确保 BLE 在主机设备上被支持和可用。关于如果完成该委托方法的更多信息，参见 CBCentralManagerDelegate Protocol Reference。</p>

<h2>发现在广播的外设</h2>

<p>主机端的第一个任务是发现应用需要连接的可用的外设。正如前面提到的，广播是外设让外界感知它存在的主要方式。你可以通过调用 CBCentralManager 类的 scanForPeripheralsWithServices:options: 方法来发现任何正在广播的外设，如下所示：</p>

<pre><code>[myCentralManager scanForPeripheralsWithServices:nil options:nil];  
</code></pre>

<p>注意：如果第一个参数填 nil，主机管理对象返回所有发现的外设，而不管他们提供什么服务。在实际的应用中，你需要指定一个 CBUUID 对象的数组，每一个 CBUUID 对象表示一个 UUID，代表外设正在广播的一个服务。当你指定了 UUID 数组，主机管理对象仅返回广播这些服务的外设，可以让你仅扫描你感兴趣的设备。  <br/>
在调用 scanForPeripheralsWithServices:options: 方法发现可用的外设后，主机管理对象每发现一个外设都调用一次它的委托方法 centralManager:didDiscoverPeripheral:advertisementData:RSSI: 。任何被发现的外设都返回一个 CBPeripheral 对象。如下面所示，你可以完成该委托方法来列出发现的任何外设：</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central  
didDiscoverPeripheral:(CBPeripheral *)peripheral       advertisementData:(NSDictionary *)advertisementData                    RSSI:(NSNumber *)RSSI {      NSLog(@"Discovered %@", peripheral.name);      ...  
</code></pre>

<p>当你发现你想连接的外设后，停止扫描其它设备以节约电量。</p>

<pre><code>[myCentralManager stopScan];    NSLog(@"Scanning stopped");  
</code></pre>

<h2>发现外设后连接它</h2>

<p>在你发现你感兴趣的外设后，可以请求连接，通过调用 CBCentralManager 类的 connectPeripheral:options: 方法。简单的调用该方法到你需要连接的指定外设，如下所示：</p>

<pre><code>[myCentralManager connectPeripheral:peripheral options:nil];  
</code></pre>

<p>假设连接成功，主机管理对象会调用它的委托方法 centralManager:didConnectPeripheral: ，你可以在建立连接后记录日志，如下所示：</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central    didConnectPeripheral:(CBPeripheral *)peripheral {    NSLog(@"Peripheral connected");    ...  
</code></pre>

<p>在与外设交互之前，需要设置外设的委托以确保期望的回调方法能响应，如下所示：<br/>
    peripheral.delegate = self;</p>

<h2>发现已连接外设的服务</h2>

<p>在与外设建立连接之后，你可以探索它的数据。探索外设的数据的第一步是发现它可用的服务。因为广播的数据量大小是有限制的，你需要探索外设的更多服务而不仅是广播。你可以调用 CBPeripheral 类的 discoverServices: 方法来发现外设提供的所有服务。</p>

<pre><code>[peripheral discoverServices:nil];  
</code></pre>

<p>注意：在实际的应用中，你不应该传递 nil 做参数，因为这样会返回外设的所有服务。外设可能会拥有很多服务，而不仅仅是你感兴趣的那些。发现服务会浪费电池和时间。更多情况下，你应该为你感兴趣的服务指定 UUID。</p>

<p>指定服务被发现时，外设（就是你已经连接上的 CBPeripheral 对象）调用 peripheral:didDiscoverServices: 委托方法。Core Bluetooth 建立一个 CBService 对象的数组&ndash;数组的每一个元素都对应一个外设已发现的服务。如下所示，你可以实现委托方法来访问数组中的服务：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral   didDiscoverServices:(NSError *)error {    for (CBService *service in peripheral.services) {        NSLog(@"Discovered service %@", service);        ... } ...  
</code></pre>

<h2>发现服务的特征</h2>

<p>假设你已经发现了你感兴趣的服务，下一步探索就是发现服务提供的所有特征。简单的调用 CBPeripheral 类的 discoverCharacteristics:forService: 方法就可以发现一个服务的所有特征，对于一个服务来说，可以操作如下所示：</p>

<pre><code>NSLog(@"Discovering characteristics for service %@", interestingService);   [peripheral discoverCharacteristics:nil forService:interestingService];  
</code></pre>

<p>注意：在实际的应用中，第一个参数不应该传递 nil，因为这样会返回一个外设服务的所有特征。因为外设的一个服务可能包含许多的特征，而不仅仅是你感兴趣的那些，发现所有特征会影响电池寿命和浪费时间。更多情况下，你应该为你感兴趣的特征指定 UUID。</p>

<p>外设指定服务的特征被发现后会调用它委托对象的  peripheral:didDiscoverCharacteristicsForService:error: 方法。Core Bluetooth 建立一个 CBCharacteristic 对象的数组&ndash;数组的每一个元素都对应一个已发现的特征。下面的例子显示了如何实现委托方法来简单的打印已发现的每一个特征：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral   didDiscoverCharacteristicsForService:(CBService *)service             error:(NSError *)error {    for (CBCharacteristic *characteristic in service.characteristics) {        NSLog(@"Discovered characteristic %@", characteristic);        ... } ...## 获取特征的值  
</code></pre>

<p><code>特征</code>包含了简单的值，用来<code>表示外设服务的更多信息</code>。例如，健康体温计服务的温度测量特征可能有一个值用来表示摄氏度。你可以直接获取或者订阅这些值。</p>

<h3>读特征值</h3>

<p>在你找到你感兴趣的服务的特征后，你可以读取你想要的特征值，通过调用 CBPeripheral 类的 readValueForCharacteristic: 方法，如下所示：</p>

<pre><code>NSLog(@"Reading value for characteristic %@", interestingCharacteristic);   [peripheral readValueForCharacteristic:interestingCharacteristic]; 当你尝试读取特征值时，外设调用它委托对象的 peripheral:didUpdateValueForCharacteristic:error: 方法获取值。如果获取成功，可以通过特征值的属性来访问这些值，如下所示：  
- (void)peripheral:(CBPeripheral *)peripheral   didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic             error:(NSError *)error {    NSData *data = characteristic.value;    // parse the data as needed    ...  
</code></pre>

<p><code>注意</code>：并非所有的特征都有可读的值。你可以通过访问 CBCharacteristicPropertyRead 来查明特征值是否可读，详情参阅 CBCharacteristic Class Reference。如果你尝试读取一个不可读的值，peripheral:didUpdateValueForCharacteristic:error: 会适当的返回一个错误。</p>

<h3>订阅特征值</h3>

<p>虽然使用 readValueForCharacteristic: 方法读取特征值能够高效满足大多数应用场景，但它不是最高效的获取值改变的方式。大多数特征值改变的时候&ndash;例如，任意时刻的心率&ndash;你应该通过订阅来获取特征值。当你订阅特征值，在值改变的时候，你能够收到外设的通知。  <br/>
你可以订阅感兴趣的特征值，通过调用 CBPeripheral 类的 setNotifyValue:forCharacteristic: 方法并指定第一个参数为 YES，如下所示：</p>

<pre><code>[peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic];  
</code></pre>

<p>当你尝试订阅（或取消订阅）一个特征值，外设会调用它委托对象的 peripheral:didUpdateNotificationStateForCharacteristic:error: 方法。如果订阅请求失败，你可以完成该委托来访问失败原因，如下所示：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral   didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic             error:(NSError *)error {    if (error) {        NSLog(@"Error changing notification state: %@",           [error localizedDescription]);    ...  
</code></pre>

<p><code>注意</code>：并非所有的特征都允许你订阅他们的值。你可以查明一个特征是否配置为可订阅的，通过访问 Characteristic Properties 枚举，详情参阅CBCharacteristic Class Reference。<br/>
在成功订阅特征值之后，在值发生改变的时候外设会给应用发通知。每次值的改变，外设都会调用它委托对象的peripheral:didUpdateValueForCharacteristic:error: 方法。要获取更新后的值，你需要实现该委托方法。</p>

<h2>写特征值</h2>

<p>在很多用户场景下，需要用到写特征值。例如，如果你的应用与一个基于 BLE 的数字温度调节器交互，你需要提供一个值让它设定室温。如果特征值是可写的，你可以给它写入一些数据（NSData类型），通过调用 CBPeripheral 类的 writeValue:forCharacteristic:type: 方法，如下所示：</p>

<pre><code>NSLog(@"Writing value for characteristic %@", interestingCharacteristic); [peripheral writeValue:dataToWrite forCharacteristic:interestingCharacteristic     type:CBCharacteristicWriteWithResponse];  
</code></pre>

<p>当尝试写一个特征值，你需要指定你需要完成的写类型。上面的例子指定的写类型是 CBCharacteristicWriteWithResponse，意味着外设会让你的应用知道写操作是否成功。Core Bluetooth 框架支持的更多写类型信息，参见 CBPeripheral Class Reference 的枚举 CBCharacteristicWriteType。<br/>
如果指定了CBCharacteristicWriteWithResponse，外设通过调用委托对象的peripheral:didWriteValueForCharacteristic:error: 方法来响应一个写请求。如果写失败，你可以实现该委托方法来获取错误原因，如下所示：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral     didWriteValueForCharacteristic:(CBCharacteristic *)characteristic               error:(NSError *)error {  if (error) {          NSLog(@"Error writing characteristic value: %@",              [error localizedDescription]);  } ...  
</code></pre>

<p>注意：特征可能仅仅允许特定类型的写操作改变它的值。你可以查明特征值允许哪些写类型，通过访问 Characteristic Properties 的相关属性，详情参考  CBCharacteristic Class Reference。</p>

<h1>外设通常要完成的任务</h1>

<p>在上一章节，我们学习了如何完成 BLE 主机端的通用任务。在本章，我们学习如何完成 BLE 外设端的通用任务。基于代码的示例可以帮助你用本地设备扮演外设的角色。具体来说你可以学习到：</p>

<ul>
<li>启动外设管理对象</li>
<li>启动外设的服务和特征</li>
<li>发布服务和特征到设备的本地数据库</li>
<li>广播服务</li>
<li>响应已连接的主机的读写请求。</li>
<li>发送更新的特征值给订阅了的主机</li>
</ul>


<p>你会发现本章的例子很简单和抽象，在你实际的应用中需要对其做适当的修改来完善。在本地设备完成外设功能的许多高级主题&ndash;包括提示，陷阱，最佳实践&ndash;在后面的章节中会覆盖到。</p>

<h2>启动外设管理</h2>

<p>用本地设备扮演外设角色的第一步就是分配和初始化一个外设管理实例（用 CBPeriphralManager 对象表示）。通过 调用 CBPeriphralManager 类的 initWithDelegate:queue:options: 方法启动外设管理，如下所示：</p>

<pre><code>myPeripheralManager =   [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil];  
</code></pre>

<p>在这个例子中，self 被设置为委托对象来接受外设的事件。当你指定 dispatch queue 为 nil，外设管理对象分发外设事件到主队列。  <br/>
当你创建一个外设管理者，外设管理者调用 peripheralManagerDidUpdateState: 委托方法。你可以实现该委托方法来确认 BLE 是否在本地外设上可用。更多实现该委托方法的详情参考 CBPeripheralManagerDelegate Protocol Reference .</p>

<h2>设置服务和特征</h2>

<p>如图 1-7，本地外设的服务和特征数据库是树形结构。你必须以类似的树形结构来设置服务和特征。完成这些任务的第一步是弄懂服务和特征时如何被定义的。</p>

<h3>服务和特征用 UUID 标识</h3>

<p>外设的服务和特征用128位的 UUID 标识，在 Core Bluetooth 框架中使用 CBUUID 对象。然而不是所有服务和特征的UUID都被蓝牙 Special Interest Group（SIG）预定义出来了。蓝牙 SIG 已经预定义了大量 UUID 为短 16 位以方便使用。例如 ，SIG 已经预定义存储为 16 位的 UUID 180D 标识心率服务。这个 UUID 等同于 128 位的 UUID：0000180D-0000-1000-8000-00805F9B34FB，预定义在蓝牙 4.0 规范，第 3 卷，3.2.1 节。  <br/>
CBUUID 类提供了便捷的工厂方法来处理 UUID。例如，在代码中你无须传递心率服务的 128 位 UUID 字符，而是简单的使用 CBUUID 的 UUIDWithString 方法。如下所示：</p>

<pre><code>CBUUID *heartRateServiceUUID = [CBUUID UUIDWithString: @"180D"];  
</code></pre>

<p>当你用一个预定义的 16 位 UUID 使用 CBUUID 对象,Core Bluetooth 会填充其余的位。</p>

<h3>为自定义的服务和特征创建自定义 UUID</h3>

<p>你可以拥有非预定义的服务和特征。前提是你需要生成的你 128 位 UUID 来标识他们。<br/>
使用命令行工具的 uuidgen 指令可以很方便的生成 128 位的 UUID。第一步，打开一个终端窗口，下一步，在终端输入 uuidgen，就可以得到一个唯一的 128 位ASCII 字符串用连字符（-）分隔的，下面是一个示例：</p>

<pre><code>$ uuidgen   71DA3FD1-7E10-41C1-B16F-4430B506CDE7  
</code></pre>

<p>你可以使用这个 UUID 创建一个 CBUUID 对象，使用 UUIDWithString 方法，如下所示：<br/>
    CBUUID *myCustomServiceUUID =    [CBUUID UUIDWithString:@&ldquo;71DA3FD1-7E10-41C1-B16F-4430B506CDE7&rdquo;];</p>

<h3>构建你的服务和特征树</h3>

<p>在你拥有自定义的 UUID 后，你可以建立可变的服务和特征，然后把他们像树形结构组织在一起。例如，如果你拥有一个特征的 UUID， 你可以建立一个可变的特征，通过调用 CBMutableCharacteristic 类的initWithType:properties:value:permissions: 方法，如下所示：</p>

<pre><code>myCharacteristic =    [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID     properties:CBCharacteristicPropertyRead     value:myValue permissions:CBAttributePermissionsReadable];  
</code></pre>

<p>当你创建一个可变的特征，设置它的属性，值，权限。你决定特征的属性和权限，是否特征值是可读写的，连接的主机是否能否订阅特征值。在这个例子中，特征值被设置为可被主机读的。关于支持可变特征的属性和权限的更多详情请参阅 CBMutableCharacteristic Class Reference 。<br/>
<code>注意</code>：如果你指定特征值，它的值被缓存，属性和权限被设置为可读的。如果你需要特征值可以被写，或者你希望特征所属的已发布服务的生命周期内特征值可以改变，需要设置值为 nil。遵循这个原则可以确保值无论什么时候外设管理对象收到主机的读写请求，值都能被动态处理。<br/>
到目前为止，你已经创建了一个可变的特征，你可以创建一个与特征关联的可变的服务。通过调用 CBMutableService 类的 initWithType:primary: 方法，如下所示：<br/>
    myService = [[CBMutableService alloc] initWithType:myServiceUUID primary:YES];<br/>
在该例中，第二个参数设置为 YES，意思是服务是主服务（相对次要服务而言的）。<code>主服务</code>描述设备的中主要功能，能被别的服务包含或引用。<code>次要服务</code>描述它引用的另外一个服务的上下文。例如，心率监控器主服务可以暴露心率传感器心率数据，而次要服务可以暴露传感器的电池数据。  <br/>
创建按服务之后，你可以通过设置服务的特征数组来关联一个特征，如下所示：<br/>
    myService.characteristics = @[myCharacteristic];</p>

<h2>发布服务和特征</h2>

<p>在构建服务和特征树之后，外设下一步要完成的是发布他们到设备的服务和特征数据库。使用 Core Bluetooth 很容易就能完成该任务。调用 CBPeripheralManager 类的 addService: 方法，如下所示：</p>

<pre><code>[myPeripheralManager addService:myService];  
</code></pre>

<p>当你调用这个方法来发布你的服务，外设管理对象调用委托方法 peripheralManager:didAddService:error:。如果有错误发生，服务将无法发布，可以实现该委托方法来获取错误原因，如下所示：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral            didAddService:(CBService *)service                    error:(NSError *)error {    if (error) {        NSLog(@"Error publishing service: %@", [error localizedDescription]);  } ...  
</code></pre>

<p><code>注意</code>：在你发布服务和任何跟它关联的特征到外设的数据库之后，服务就会被存储并且不能对它再做修改。</p>

<h2>广播服务</h2>

<p>当你发布服务和特征到设备的服务特征数据库之后，你已经做好了广播的准备工作，广播可以被正在侦听的主机接收。如下例子所示，可以通过调用 CBPeripheralManager 类的 startAdvertising: 方法广播服务，并且可以传递一个 NSDictionary 对象作为广播数据，如下所示：</p>

<pre><code>[myPeripheralManager startAdvertising:@{ CBAdvertisementDataServiceUUIDsKey :    @[myFirstService.UUID, mySecondService.UUID] }];  
</code></pre>

<p>在这个例子中，字典对象唯一的键 CBAdvertisementDataServiceUUIDsKey，它的值是一个 CBUUID 对象的数组，代表你需要广播的服务的 UUID。在字典中你可以指定的键的详细描述在 CBCentralManagerDelegate Protocol Reference 的 Advertisement Data Retrieval Keys 部分。<code>外设管理对象仅支持两个键：CBAdvertisementDataLocalNameKey 和 CBAdvertisementDataServiceUUIDsKey</code>。</p>

<p>当你广播外设的数据，外设管理对象调用委托方法 peripheralManagerDidStartAdvertising:error:。如果有错误发生，服务没有被广播出去，实现该委托方法获取错误原因，如下所示：</p>

<pre><code>- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral                                       error:(NSError *)error {    if (error) {        NSLog(@"Error advertising: %@", [error localizedDescription]); } ...  
</code></pre>

<p>注意：数据广播基于“尽力而为”的原则来完成。因为空间是有限的，可能同时有多个应用的广播。更多详情，参见CBPeripheralManager Class Reference 的 startAdvertising: 方法。  <br/>
广播行为也受应用后台的影响，这个主题在下一章讲述。</p>

<p>一旦外设开始广播数据，远程主机就能发现和初始化到外设的连接。</p>

<h2>响应主机的读写请求</h2>

<p>在被一个或多个远程主机连接后，你可以开始接收来自主机的读写请求。请使用适当的方式响应这些请求。下面的例子描述了如何处理这些请求。  <br/>
当一个已连接的主机请求读特征值，外设管理对象会调用 peripheralManager:didReceiveReadRequest: 委托方法。该委托方法用 CBAttRequest 对象分发请求，CBAttRequest 对象包含一些属性可以用来完成请求。  <br/>
例如，当你收到一个要读特征值的简单请求，从委托方法中接收到的 CBATTRequest 对象属性能够用来保证你设备数据库中的特征与远程主机指定的读请求的特征相符合。你可以实现该委托方法，如下所示：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral    didReceiveReadRequest:(CBATTRequest *)request {    if ([request.characteristic.UUID isEqual:myCharacteristic.UUID]) {        ...  
</code></pre>

<p>如果特征的 UUID 匹配，下一步就是确保读请求的特征值的偏移没有越界。如下面的代码所示，你可以使用 CBATTRequest 对象的 offset 属性来确保读请求没有越界：<br/>
    if (request.offset > myCharacteristic.value.length) {    [myPeripheralManager respondToRequest:request        withResult:CBATTErrorInvalidOffset];    return;   }<br/>
假设请求的 offset 通过检验，现在可以设置请求特征属性值（默认是nil）为你本地外设的特征值，同时需要考虑读请求的 offset：<br/>
    request.value = [myCharacteristic.value subdataWithRange:NSMakeRange(request.offset, myCharacteristic.value.length - request.offset)];</p>

<p>在你设置值之后，响应远程主机告知请求已经成功完成。通过调用 CBPeripheralManager 类的  respondToRequest:withResult: 方法，传回请求（已经更新值的请求）和请求的结果，如下所示：</p>

<pre><code>[myPeripheralManager respondToRequest:request withResult:CBATTErrorSuccess];    ...  
</code></pre>

<p>每次 peripheralManager:didReceiveReadRequest: 委托方法被调用时都调用 respondToRequest:withResult: 方法。</p>

<p><code>注意</code>:如果特征的 UUID 不匹配，或者读操作不能完成，你不应该尝试填充请求对象。你应该立即调用 respondToRequest:withResult: 方法并提供一个标识失败原因的结果。你可以指定的可能的结果列表，参见  Core Bluetooth Constants Reference 的 CBATTError Constants 枚举。</p>

<p>处理已连接主机的写请求同样简单。当一个已连接主机发送写请求，外设管理对象调用 peripheralManager:didReceiveWriteRequests: 委托方法。这一次，委托方法用一个包含 CBATTRequest 对象的数组分发请求，数组每一个元素表示一个写请求。在你确认写请求完成后，你可以如下所示写特征值：</p>

<pre><code>myCharacteristic.value = request.value;  
</code></pre>

<p>虽然上面没有完整的示范，但在写特征值时也要考虑请求的 offset 属性。</p>

<p>像响应读请求一样，peripheralManager:didReceiveWriteRequests: 调用的时候都调用 respondToRequest:withResult: 方法。意思是说，尽管你从 peripheralManager:didReceiveWriteRequests: 方法中接收了一个包含 CBATTRequest 对象的数组，单respondToRequest:withResult: 第一个参数需要填一个 CBATTRequest 对象。你需要像如下代码所示传递数组的第一个请求：</p>

<pre><code>[myPeripheralManager respondToRequest:[requests objectAtIndex:0]    withResult:CBATTErrorSuccess];  
</code></pre>

<p><code>注意</code>：多个请求与单个请求的处理方式一致&ndash;如果多个请求的任一的请求不能被完成，你就不应该完成所有请求。取而代之的是立即调用 respondToRequest:withResult: 方法并提供一个描述失败原因的结果。</p>

<h2>发送更新特征到订阅的主机</h2>

<p>通常，连接的主机会订阅一个或多个特征值。这样在订阅的特征值改变的时候可以发送通知给主机。下面的示例描述如何实现.  <br/>
当一个连接的主机订阅特征值，外设管理对象调用peripheralManager:central:didSubscribeToCharacteristic: 委托方法。</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral                  central:(CBCentral *)central   didSubscribeToCharacteristic:(CBCharacteristic *)characteristic {    NSLog(@"Central subscribed to characteristic %@", characteristic);    ...  
</code></pre>

<p>用上面的委托方法作为给主机发送更新值的开始步骤。<br/>
接下来，获取更新的特征值然后发送给主机，通过调用 CBPeripheralManager 类的 updateValue:forCharacteristic:onSubscribedCentrals: 方法：<br/>
    NSData *updatedValue = // fetch the characteristic&rsquo;s new value  BOOL didSendValue = [myPeripheralManager updateValue:updatedValue    forCharacteristic:characteristic onSubscribedCentrals:nil];当你调用上面的方法给订阅的主机发送特征值，你可以在最后一个参数指定你想更新的主机。在上面的例子中，如果你指定 nil，所有连接并且订阅的主机都会更新（仅仅连接但没有订阅的主机会被忽略）。  <br/>
updateValue:forCharacteristic:onSubscribedCentrals: 方法返回一个布尔值表明更新值是否正确发送到订阅的主机。如果用来传输更新值的底层队列已经满了，该方法返回 NO。在有传输队列可用时外设管理对象就会调用peripheralManagerIsReadyToUpdateSubscribers: 方法。你可以实现该委托方法重新发送，通过调用 updateValue:forCharacteristic:onSubscribedCentrals: 方法。  <br/>
<code>注意</code>：使用通知发送一个简单的数据包给订阅的主机。当你更新一个订阅的主机，你应该通过调用 updateValue:forCharacteristic:onSubscribedCentrals: 在通知中一次性发送全部更新的值。根据特征值的大小，并非全部的数据会被通知传输。如果发生了这种情况，应该在主机端通过调用 readValueForCharacteristic: 方法获取全部值。</p>

<h1>iOS 应用 Core Bluetooth 后台处理</h1>

<p>在 iOS 应用中，搞清楚应用是运行在前台还是后台是非常重要的。应用后台和前台必须有不同的行为，因为 iOS 设备的资源是很有限的。完整的 iOS 多任务讨论，参见 “App States and Multitasking” in iOS App Programming Guide .  <br/>
默认情况下，Core Bluetooth 许多常用的任务&ndash;不论是主机端还是外设端&ndash;在后台或挂起状态下都是不可用的。你可以声明应用支持 Core Bluetooth 后台执行模式允许你的应用从挂起状态唤醒来处理特定的蓝牙相关事件。即使你的应用不支持全范围的后台处理，仍然可以要求系统在有重要事件发生时提示应用。  <br/>
即使你的应用支持 Core Bluetooth 后台执行模式，它也不会永远运行。在某些时候，系统会因为给当前位于的前台应用释放内存而终结你的应用&ndash;这将导致任何当前活动或者挂起的连接丢失。 自 iOS 7，Core Bluetooth 支持给主机端和外设端保存状态信息，也支持在应用启动时恢复状态信息。你可以在需要长期使用蓝牙设备的应用中使用该特征。</p>

<h2>仅支持前台的应用</h2>

<p>大多数 iOS 应用，除非你要求完成指定的后台任务，你的应用在转到后台状态后很快就会进入挂起状态。在挂起状态下，应用不能完成蓝牙相关任务，也不能感知到任何蓝牙相关事件。</p>

<p>在主机端，仅支持前台的应用&ndash;即没有声明支持 Core Bluetooth 后台执行模式的应用&ndash;在后台状态或者挂起状态不能扫描和发现任何广播的设备。在外设端，仅支持前台的应用无法在后台状态或者挂起状态下广播，并且主机对已发布的特征值的访问也会接收到错误。</p>

<p>依据使用方式不同，默认的行为也会以多种方式影响你的应用。例如，假设你正在跟一个已连接的外设交互数据，现在假设你的应用状态挂起状态（比如，由于用户打开了另外一个应用），当你的应用在挂起状态，如果到外设的连接丢失，你不会感知到任何断连的发生，直到你的应用重新调度到前台状态。</p>

<h3>利用外设连接选项</h3>

<p>在仅支持前台运行的应用处于挂起状态的时候，所有蓝牙相关的事件都被系统放在队列里面，直到应用调度为前台状态后才会分发给应用。也就是说，主机端特定的事件发生时，Core Bluetooth 提供了一个方式提示用户。  <br/>
你可以在连接远程外设的时候，使用下面的外设连接选项来调用 connectPeripheral:options: 方法来提示用户。</p>

<ul>
<li><code>CBConnectPeripheralOptionNotifyOnConnectionKey</code>—在成功连接之后，如果你希望应用在挂起状态下系统还能显示提示信息，请包含该key。<em> <code>CBConnectPeripheralOptionNotifyOnDisconnectionKey</code>—如果在断连的时候应用处于挂起状态，你希望系统显示指定外设的断连提示信息，请包含该key。</em> <code>CBConnectPeripheralOptionNotifyOnNotificationKey</code>—如果应用处于挂起状态，你希望显示从指定外设接收到的所有通知信息，请包含该key。  <br/>
更多关于外设连接选项的详情，参阅 CBCentralManager Class Reference 的 Peripheral Connection Options constants。

<h2>Core Bluetooth 后台执行模式</h2>

<p>如果应用需要在后台模式下完成某些蓝牙相关的任务，应用必须在其信息属性列表文件中（Info.plist）声明为 Core Bluetooth 后台执行模式。当你声明了后台模式，系统在将应用从挂起状态唤醒为前台状态来处理蓝牙相关的事件。这个功能对定期与 BLE 设备交互的应用来说非常重要，比如心率监控器。  有两种 Core Bluetooth 后台执行模式可以声明&ndash;一个用于完成主机端功能，一个用于完成外设端功能。如果应用要完成两个角色，需要同时声明两个后台执行模式。通过设置 <code>Info.plist</code> 文件的 <code>UIBackgroundModes</code> 键来声明Core Bluetooth 后台执行模式，键的值是一个数组，包含如下字符串：</p></li>
<li><code>bluetooth-central</code> 应用与 BLE 外设通信（即应用作为主机端）。</li>
<li><code>bluetooth-peripheral</code> 应用共享数据（即应用作为外设端）。</li>
</ul>


<p><code>注意</code>：在 XCode 中，属性列表编辑器默认展示键位可读的字符串而不是实际的键名称。右键菜单选择 Show Raw Keys/Values 可以显示实际的键名称。</p>

<p>更多如何配置 Info.plist 文件的详情，参阅 Property List Editor Help。</p>

<h3>蓝牙主机后台执行模式</h3>

<p>如果应用用来实现主机功能，在 Info.plist 文件中包含了 UIBackgroundModes 键，设置其值为 bluetooth-central，Core Bluetooth 框架允许应用在后台运行来处理特定的蓝牙相关的任务。当你的应用位于后台，你仍然可以发现和连接外设，探索外设并于外设交互数据。另外，系统会在 CBCentralManagerDelegate 或者 CBPeripheralDelegate 委托方法被调用时唤醒应用，允许你的应用处理重要的主机端的事件，比如连接建立或关闭，外设发过来特征值的更新，主机管理对象状态改变。  <br/>
虽然应用在后台时你也可以完成许多蓝牙相关的任务，但要记住，应用在后台时扫描外设与前台时扫描外设时很不一样的。在你应用处于后台时，扫描设备需要特别注意如下事项：</p>

<ul>
<li><code>CBCentralManagerScanOptionAllowDuplicatesKey 扫描选项键会被忽略，并且多个广播外设的发现会被合并成一个发现事件。</code></li>
<li><code>如果所有的应用都在后台扫描外设，你主机扫描广播外设的间隔时长会增加。这会导致发现广播设备的时间变长。</code></li>
</ul>


<p>这些与前台不同的地方帮助我们最小化无线使用，增加 iOS 设备电池使用寿命。</p>

<h3>蓝牙外设后台执行模式</h3>

<p>如果应用用来实现外设功能，在 Inof.plist 文件中包含 UIBackgroundModes 键，设置其值为 bluetooth-peripheral。如果应用中包含了该键值对，系统会唤醒你的应用来处理读，写，订阅事件。  <br/>
除了允许你的应用唤醒来处理已连接主机的读，写，订阅请求外，Core Bluetooth 框架还允许你的应用在后台时发广播。但需要注意，应用在后台时广播和在前台时广播是不一样的，当应用后台广播时，需要注意如下事项：</p>

<ul>
<li><code>CBAdvertisementDataLocalNameKey 广播键被忽略掉，外设的本地名称不会被广播。</code></li>
<li><code>所有包含 CBAdvertisementDataServiceUUIDsKey 广播键的服务被放在一个特殊的“溢出”区，他们仅能被希望扫描他们的 iOS 设备发现。</code></li>
<li><code>如果所有广播的应用都位于后台，外设发送广播包的频率会降低。</code></li>
</ul>


<h2>小心谨慎的使用后台执行模式</h2>

<p>虽然在某些特定的用户场景下，声明应用支持后台执行模式是很有必要的，但你应该总是为后台处理负责。因为完成许多蓝牙相关的任务都需要使用设备主板上的无线电，而无线电的使用会严重影响电池使用寿命，所以要尽量少的使用后台。被唤醒的应用应该尽可能快得完成蓝牙相关事件的处理，然后再次进入挂起状态。</p>

<p>声明为蓝牙后台执行模式的应用需要遵循如下的基本准则：</p>

<ul>
<li><code>应用必须提供一个基于会话的接口允许用户决定开始和停止分发蓝牙相关的事件。</code></li>
<li><code>一旦被唤醒，应用有大概10秒钟的时间来完成任务。理想情况下，应用需要尽可能快的完成任务然后进入挂起状态。应用在后台花太多时间可能会被系统杀掉。</code></li>
<li><code>应用不应该因为不相关的任务被系统唤醒来完成不相关的任务（实在翻译不出来它的本意，估摸着是这个意思吧）。</code></li>
</ul>


<p>关于应用在后台状态下应有的更多详情，参见“Being a Responsible Background App” in iOS App Programming Guide 。</p>

<h2>在后台完成长时间的任务</h2>

<p>一些应用需要在后台状态下使用 Core Bluetooth 完成长期的任务。例如，假设你在开发一个管理 BLE 的智能门锁的家庭安全应用。当用户离开家的时候，门自动落锁，当用户回家的时候，门自动开锁&ndash;整个过程中，应用一直在后台。当用户离开家，iOS 设备会超出锁的连接范围，导致到门锁的连接断连。这个时候，应用能能够调用 CBCentralManager 类的 connectPeripheral:options: 方法，并且因为连接请求不会超时，iOS 设备会在用户回家的时候重连。  <br/>
现在假设用户离开家一些天。如果应用在用户离开的时候被系统终止了，当用户回家时应用就不能够重连门锁了，用户就开不了门锁了。类似的这些应用，需要持续使用 Core Bluetooth 实现长期任务，例如监控活动，挂起连接等。</p>

<h3>状态保存和恢复</h3>

<p>因为 Core Bluetooth 内建状态保存和恢复机制，你的应用可以选择性的要求系统代表应用的主机或外设管理对象完成他们特定的蓝牙相关的任务，即使应用没有在运行。当任务完成后，系统重启你的应用到后台然后给应用机会恢复应用的状态并合理的处理事件。在上面描述到的家庭安全应用中，系统可以在用户回家，连接请求完成后监控连接请求，重启应用来处理 centralManager:didConnectPeripheral: 回调。</p>

<p>Core Bluetooth 既支持主机端，也支持外设端的状态保存和恢复。当你的应用作为主机端，添加了状态保存和恢复，系统会在终结你应用时保存你的主机管理对象状态（如果应用有多个主机管理对象，你可以选择其中的一个来让系统跟踪它）。对于一个给定的 CBCentralManager 对象，系统跟踪如下信息：</p>

<ul>
<li><code>主机管理对象扫描的服务（还有扫描开始后指定的任何扫描选项）。</code></li>
<li><code>主机正在连接正在尝试连接的外设和已经连接的外设。</code></li>
<li><code>主机订阅的特征。</code></li>
</ul>


<p>应用作为外设端利用状态保存和恢复跟主机端类似。对于一个 CBPeripheralManager 对象，系统跟踪如下信息：</p>

<ul>
<li><code>正在广播的外设管理对象的数据。</code></li>
<li><code>外设发布到设备数据库的服务和特征。</code></li>
<li><code>订阅特征值的主机。</code></li>
</ul>


<p>当应用被系统重启到后台模式（比如因为应用正在扫描的设备被发现），你可以重新实例化应用的主机和外设管理对象，恢复他们的状态。下面的一节详细描述如何利用状态存储和恢复。</p>

<h3>添加状态保存和恢复支持</h3>

<p>状态保存和恢复在 Core Bluetooth 中是可选的特性。你可以按照下面的处理添加保存和恢复功能：</p>

<ol>
<li>(必要）选择状态保存和恢复</li>
<li>(必要）重新实例化主机和外设管理对象</li>
<li>(必要) 实现相应的恢复委托方法</li>
<li>(可选) 更新初始化处理</li>
</ol>


<h4>选择状态保存和恢复</h4>

<p>要实现状态保存和恢复，在初始化主机或者外设的管理对象时简单的提供一个恢复唯一标识符就可以了。<code>恢复标识符</code>是一个<code>表示主机或者外设管理对象的字符串</code>。字符串的值只能被你的代码鉴别，这个字符串的存在告诉 Core Bluetooth 需要保存标记对象的状态。Core Bluetooth 只会保存拥有恢复标识符的对象状态。</p>

<p>例如，在主机端，如果使用 CBCentralManager 对象的一个实例来完成状态保存和恢复，需要在分配和初始化主机管理对象的时候，指定 CBCentralManagerOptionRestoreIdentifierKey 并提供一个恢复标识符，如下所示：</p>

<pre><code>myCentralManager =    [[CBCentralManager alloc] initWithDelegate:self queue:nil     options:@{ CBCentralManagerOptionRestoreIdentifierKey:     @"myCentralManagerIdentifier" }];  
</code></pre>

<p>尽管上面的例子是关于主机的状态保存和恢复，但外设管理对象也是类似的实现方式。 在分配和初始化外设管理对象的时候，指定 CBPeripheralManagerOptionRestoreIdentifierKey 并提供一个恢复标识符。<br/>
<code>注意</code>：因为应用可以有多个 CBCentralManager 实例和多个 CBPeripheralManager 实例对象，要确保恢复标识符是唯一的，那样系统才能正确区分不同的主机和外设管理对象。</p>

<h4>重新实例化化主机和外设管理对象</h4>

<p>当应用被系统重启到后台，你要做的第一件事就是依据恢复标识符对相应的主机和外设重新实例化他们的状态。如果你的应用仅有一个主机或者外设管理对象，并且这个管理对象在应用的生命周期内都存在，那么这个步骤你不用做任何处理。</p>

<p>如果你的应用不止使用一个主机或外设管理对象，或者如果你只使用一个管理对象但是它在应用的生命周期内不是一直存在，那么应用在被系统重启后需要知道重新实例化哪一个管理对象。你可以访问系统在你的应用终止时为你保存的一个包含所有恢复标识符的列表，通过在实现 application:didFinishLaunchingWithOptions: 委托方法时使用启动选项键（UIApplicationLaunchOptionsBluetoothCentralsKey or UIApplicationLaunchOptionsBluetoothPeripheralsKey）。</p>

<p>例如，应用重启时，你可以获取系统为你应用保存的所有的主机管理对象的恢复标识符，如下所示：</p>

<pre><code>- (BOOL)application:(UIApplication *)application    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    NSArray *centralManagerIdentifiers =        launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey]; ...  
</code></pre>

<p>在你获得恢复标识符列表后，可以循环遍历然后重新实例化主机管理对象。</p>

<p><code>注意</code>：当应用重启，系统只会为正在完成某些蓝牙相关任务的主机和外设管理对象提供恢复标识符。</p>

<h4>实现相应的恢复委托方法</h4>

<p>重新实例化相应的主机和外设管理对象后，用蓝牙系统的状态同步管理对象的状态并存储下来。为了在系统帮应用处理的任务的基础上（应用没有运行的时候系统代做的处理）加快应用处理，你需要实现一些恢复的委托方法。对于一个主机管理对象，需要实现 centralManager:willRestoreState: 委托方法，对已一个外设管理对象，需要实现 peripheralManager:willRestoreState: 委托方法。</p>

<p><code>重要</code>：<strong><em>对于选择保存和恢复状态的应用，centralManager:willRestoreState: 和 peripheralManager:willRestoreState: 是应用重启到后台状态完成某些蓝牙相关任务的第一个方法。对于不选择保存和恢复状态的应用（或者启动时不存储任何东西的应用），centralManagerDidUpdateState: 和 peripheralManagerDidUpdateState: delegate 是应用重启后调用的第一个方法。</em></strong></p>

<p>在上面的委托方法中，最后一个参数是一个字典，包含应用终止时保存的管理对象的信息。  <br/>
恢复 CBCentralManager 对象的状态，使用 centralManager:willRestoreState: 委托方法里提供的字典的键。举个例子，如果在应用终止时主机管理对象拥有任何活动的或挂起的连接，系统会代表应用继续监控他们。如下所示，你可以使用 CBCentralManagerRestoredStatePeripheralsKey 来获取主机管理对象已经连接或者正在尝试连接的所有外设的列表：</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central        willRestoreState:(NSDictionary *)state {      NSArray *peripherals =  state[CBCentralManagerRestoredStatePeripheralsKey];      ...  
</code></pre>

<p>如何处理上面的列表依赖于你的使用场景。例如，如果应用拥有主机管理对象已经发现的的外设列表，你可能想添加已存储的外设到列表中来保持他们的引用。要确保设置了外设的委托方法，以确保能接收想要的回调。  <br/>
你可以在 peripheralManager:willRestoreState: 委托方法中类似的存储 CBPeripheralManager 对象。</p>

<h4>更新初始化处理</h4>

<p>在完成必要的三个步骤后，你可能想要更新主机和外设的管理对象的初始化处理。尽管这是一个可选的步骤，但对于应用的流畅运行是很重要的。举个例子，你的应用可能在探索已连接外设的数据的过程中被终止了，这个时候应用已经被这个外设存储，应用并不知道它被终止时发现处理完成了多少。你可能想在你在发现处理时被终止的那个点继续。 <br/>
例如，在 centralManagerDidUpdateState: 委托方法中初始化应用时，可以找出已恢复的外设（在应用终止前），如下所示：</p>

<pre><code>NSUInteger serviceUUIDIndex =    [peripheral.services indexOfObjectPassingTest:^BOOL(CBService *obj,    NSUInteger index, BOOL *stop) {        return [obj.UUID isEqual:myServiceUUIDString];    }];    if (serviceUUIDIndex == NSNotFound) {    [peripheral discoverServices:@[myServiceUUIDString]];    ...如上面的例子所示，如果系统在完成发现服务之前终止应用，在这个时候通过调用 discoverServices 方法开始探索恢复的外设数据。如果应用成功发现了服务，你可以检查服务的特征（以及是否已经订阅他们）。通过这种方式更新初始化处理，你可以确保你在正确的时间调用正确的方法。  
</code></pre>

<h1>与远程外设交互的最佳实践</h1>

<p>Core Bluetooth 框架提供了很多到主机端应用的透明传输。应用有控制权，并负责实现大多数主机端任务，例如设备发现和连接，探索，以及与远程外设交互数据。本章为你在这个层面开发 iOS 应用提供负责任的指导和最佳实践。</p>

<h2>重视无线电使用和电池消耗</h2>

<p>开发与 BLE 设备交互的应用时，记住 BLE 通信贡献设备无线电来传输信号。因为其他形式的无线通讯也需要使用设备的无线电&ndash;比如WIFI，经典蓝牙（应该是说MFI蓝牙之类吧），还有其他使用 BLE 蓝牙的应用&ndash;开发应用时要最小化无线电的使用。  <br/>
开发应用时最小化无线电使用是非常重要的，因为无线电使用对电池使用寿命影响很严重。下面的指导能帮助你很好的使用设备无线电。这样你的应用会更优美，设备电池也能使用更久。</p>

<h3>只有需要时才扫描设备</h3>

<p>当调用 CBCentralManager 类的 scanForPeripheralsWithServices:options: 方法发现正在广播服务的远程外设时，你的主机设备使用无线电来侦听广播设备直到你明确告诉它要停止。<br/>
除非你要发现更多的设备，否则在发现一个你想要连接的设备后停止扫描其它设备。使用 CBCenteralManager 类的stopScan 方法停止扫描其它设备。</p>

<h3>只有需要时才指定 CBCentralManagerScanOptionAllowDuplicatesKey 选项</h3>

<p>远程外设可能每秒发送多个广播包来向侦听的主机宣告它的存在。当使用 scanForPeripheralsWithServices:options: 方法扫描时，<code>默认的行为是将一个广播外设的多个发现合并成一个发现事件</code>&ndash;意思是说，主机管理对象为每个发现的新外设调用 centralManager:didDiscoverPeripheral:advertisementData:RSSI: 方法，而不管它接到了多少广播包。已经发现的外设在更改它的广播包的时候，主机也会调用这个委托方法。<br/>
如果你要改变默认的行为，你可以在调用 scanForPeripheralsWithServices:options: 时指定 CBCentralManagerScanOptionAllowDuplicatesKey 常量作为扫描选项。这样，主机每从外设收到一个广播包都回产生一个发现事件。关闭默认的行为在某些用用场景下是很有用的，例如初始化一个基于外设接近度的连接（使用外设接收信号强度指示器的值 RSSI）。需要重视，指定该选项严重影响电池使用寿命，所以只有在确实需要完成类似的应用场景时才指定该选项。</p>

<h3>明智的探索外设数据</h3>

<p>外设的服务和特征可能比应用感兴趣的多。发现外设所有的服务和特征对电池和应用体验都由负面的影响。所有你应该值查找和发现和你应用相关的服务和特征。<br/>
例如，假设你已经连接到一个外设，外设有很多服务可用，但你的应用仅仅需要访问他们中间的两个。你可以仅仅查找和发现这两个服务，通过调用 CBPeripheral 类 discoverServices: 方法，并传递一个包含这两个服务的 UUID 的数组，如下所示：</p>

<pre><code>[peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]];
</code></pre>

<p>在你发现这两个你感兴趣的服务之后，你可以类似的查找和发现你感兴趣这两个服务的特征。再次简单的传递一个代表你想发现的特征的 UUID 数组，调用 CBPeripheral 类的 discoverCharacteristics:forService: 方法。</p>

<h3>订阅经常变化的特征值</h3>

<p>如之前描述的，有两种方法获取特征值：</p>

<ul>
<li>你可以明确的轮询特征值，在每次你需要获取值的时候调用 readValueForCharacteristic: 方法。</li>
<li>你可以订阅特征值，通过调用 setNotifyValue:forCharacteristic: 方法，这样每次特征值改变都可以收到来自外设的一个通知。</li>
</ul>


<p>最佳做法尽可能的订阅特征值，特别是值经常改变的情况下。</p>

<h3>从设备获取你需要的所有数据后断开连接</h3>

<p>连接不再需要时，断开连接可以降低无线电的使用。下面两种情况下你应该断开设备连接：</p>

<ul>
<li><code>你订阅的所有特征值已经停止发送通知了。（你可以确认特征值是否是能通知，通过访问特征的 isNotifying 属性）</code></li>
<li><code>你已经从外设获取了你需要的所有数据。</code></li>
</ul>


<p>上面任意一种情况下，取消订阅然后断开与外设的连接。通过调用 setNotifyValue:forCharacteristic: 方法取消订阅特征值。通过调用 CBCentralManager类的 cancelPeripheralConnection: 方法取消与外设的连接，如下所示：</p>

<pre><code>[myCentralManager cancelPeripheralConnection:peripheral];
</code></pre>

<p><code>注意</code>: cancelPeripheralConnection 方法时非阻塞的，任何到外设的 CBPeripheral 类的尝试断连的命令都是未决的，可能完成也可能没完成。因为其他应用可能仍然拥有一个到外设的连接，取消一个本地连接不保证底层物理链路能立即断连。然而从应用的角度来看，外设是被认为断连的，主机管理对象会调用 centralManager:didDisconnectPeripheral:error: 委托方法。</p>

<h2>重连外设</h2>

<p>使用 Core Bluetooth 框架，有三种方式重连外设：</p>

<ul>
<li><code>获取已知外设的列表</code>&ndash;之前发现或者连接的外设&ndash;使用 retrievePeripheralsWithIdentifiers: 方法。如果你查找的外设在里面，尝试连接它。连接选项在后面的描述中。</li>
<li><code>获取当前连接的外设列表</code>，使用 retrieveConnectedPeripheralsWithServices: 方法。如果你查找的外设在里面，尝试连接它。连接选项在后面的描述中。</li>
<li><code>扫描并发现外设</code>，使用  scanForPeripheralsWithServices:options: 方法。如果你发现了外设，连接它。连接选项在后面的描述中。</li>
</ul>


<p>依赖于具体的使用场景，连接设备时你可能不需要每次都扫描和发现相同的设备。取而代之的是，你可以先尝试其他方式重连。如图 5-1 所示，一个重连工作流可能像下面列出的按顺序尝试每一个选项。</p>

<p><code>注意</code>：依据不同的使用场景，重连选项的选择和次序是有很大差异的。例如，你可能决定不使用第一个连接选项，也可能决定同时尝试前面两个选项。</p>

<h3>获取已知外设列表</h3>

<p>你第一次发现外设时，系统生成一个 UUID 代表这个外设。你可以存储这个标识（比如用 NSUserDefault），稍候可以使用它来尝试重连外设，通过调用 CBCentralManager 类的 retrievePeripheralsWithIdentifiers: 方法。下面的例子描述了一种重连以前连接过的外设的方法。<br/>
当应用启动时，调用 call the retrievePeripheralsWithIdentifiers: 方法，传递包含外设标识符的数组，如下所示：</p>

<pre><code>knownPeripherals =    [myCentralManager retrievePeripheralsWithIdentifiers:savedIdentifiers];
</code></pre>

<p>主机管理对象尝试匹配你提供的标识符并返回一个包含 CBPeripheral 对象的数组。如果没有任何匹配，数组是空的，你应该尝试其他的重连选项。如果数组不为空，让用户选择（在 UI ）需要重连哪个外设。<br/>
当用户选择一个外设，调用CBCentralManager 类的 connectPeripheral:options: 方法重连外设。如果外设任然可用于连接，主机调用 centralManager:didConnectPeripheral: 委托方法，外设就被成功连接了。<br/>
<code>注意</code>：有些情况下外设不能被连接。例如，外设不在主机附近。另外，一些 BLE 设备使用周期性改变的随机设备地址，这样尽管设备在附近，它的地址从上次被系统发现以来发生了改变，上面任意一种情况下你尝试连接 CBPeripheral 对象都不会符合实际的外设。如果你因为外设地址改变而无法重新连接它，你需要重新发现外设，通过调用 scanForPeripheralsWithServices:options: 方法。</p>

<h3>获取已连接外设列表</h3>

<p>另外一种重连的方式时通过检查外设是否已经连接到系统了（比如被其他的应用连接了）。你可以通过调用 CBCentralManager 类的 retrieveConnectedPeripheralsWithServices: ，该方法返回一个 CBPeripheral 对象的数组，表示当前已连接的外设。<br/>
因为当前可能不止一个外设连接到系统，你需要传递一个 CBUUID 的数组（服务的 UUID）来获取当前连接到系统并且包含了指定 UUID 服务的外设。如果当前没有外设连接到系统，数组为空。你需要尝试其他重连选项。如果数组不为空，让用户选择（在 UI）需要重连哪个威外设。<br/>
假设用户发现和选择了他想要的外设，调用 CBCentralManager 类的 connectPeripheral:options: 方法在本地连接它到你的应用。（尽管设备已经连接到系统，你仍然需要在本地连接它到你的应用才能开始探索和交互数据）。本地连接建立后，主机管理对象调用 centralManager:didConnectPeripheral: 方法，外设就被成功重连了。</p>

<h1>设置本地设备为外设端的最佳实践</h1>

<p>和许多主机端传输一样，Core Bluetooth 框架给你控制权以全方位的控制外设端。本章在你在这个层面开发应用提供负责任的指导和最佳实践。</p>

<h2>广播注意事项</h2>

<p>设置外设完成外设端功能的时候，广播外设数据是一个重要部分。下面的内容帮助你以适当的方式完成广播。</p>

<h3>考虑广播数据的限制</h3>

<p>你通过传递给 CBPeripheralManager 类 startAdvertising: 方法一个包含广播数据的字典来广播外设数据。当你创建一个广播的字典，需要记住它们有什么限制，有哪些限制。<br/>
虽然普通的广播包可以携带外设的大量信息，但你只能广播设备的本地名称和你想广播出去的服务的 UUID。也就是说，当你创建广播字典，<code>你只能广播下面的两个键：CBAdvertisementDataLocalNameKey 和 CBAdvertisementDataServiceUUIDsKey</code>。如果你指定其他任何 key 都会收到一个错误。<br/>
还有一个限制是关于广播数据可以使用多少空间的。当应用位于前台时，这两个键的任意组合最多能在初始化的广播数据中使用 28 字节空间。如果这个空间用完了，那么可以有额外的 10 个字节仅供扫描响应时本地名称使用。任何不适合分配空间的服务 UUID 都被添加到一个特殊的“溢出”区。他们只能被 iOS 设备明确的扫描来被发现。如果应用位于后台，本地名称不会被广播，所有的服务 UUID 都被放在溢出区。</p>

<p><code>注意</code>：空间大小不包含请求的每个新数据类型的 2 个字节的头部。</p>

<h2>仅广播必要的数据</h2>

<p>因为广播外设数据需要使用本地设备的无线电（还有电池电量），只有在你需要其他设备连接你的时候才广播。一旦连接后，设备可以与外设直接探索和交互数据，不再需要广播。所以在 BLE 传输不必要广播的时候停止广播，可以最小化无线使用，增强用户体验，节省电池。在外设端停止广播，简单的调用 CBperipheralManager 类的 stopAdvertsing 方法，如下所示：</p>

<pre><code>[myPeripheralManager stopAdvertising];
</code></pre>

<h3>让用户决定什么时候广播</h3>

<p>往往只有用户才知道什么时候需要广播。例如，你知道附近没有任何 BLE 设备时，广播数据没有任何意义。因为应用总是不知道附近有什么设备，所以提供一个 UI 接口让用户决定什么时候广播。</p>

<h2>配置特征</h2>

<p>当你创建一个可变的特征，你可以设置它的属性和权限。这些设置决定了主机如何访问特征值，如何与特征交互。根据应用需求来决定如何配置属性和权限，下面提供了一些指导：</p>

<ul>
<li><code>允许所有已连接的主机订阅特征。</code></li>
<li><code>对来自未配对主机的访问，保护敏感的特征值。</code></li>
</ul>


<h3>配置特征以支持通知</h3>

<p>强烈建议主机订阅经常变化的外设的特征值。<br/>
当你创建一个可变的特征，通过设置 CBCharacteristicPropertyNotify 常量来配置特征的属性支持订阅，如下所示：</p>

<pre><code>myCharacteristic = [[CBMutableCharacteristic alloc]    initWithType:myCharacteristicUUID    properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotify    value:nil permissions:CBAttributePermissionsReadable];
</code></pre>

<p>在这个例子中，特征值时可读并且可被已连接的主机订阅。</p>

<h3>需要配对连接才能访问敏感数据</h3>

<p>依赖具体的使用场景，你可能要保证服务的某些特征值的安全（这句翻不出来，大概是不能随便被别人获取的意思吧）。例如，假设你需要提供一个社交媒体个人服务。这个服务有很多特征，他们的值表示会员的个人资料，如姓名，邮箱地址等。你更可能只希望新人的设备才能获取会员的邮箱地址。<br/>
你可以通过设置特征属性和权限来保证只有信任的设备才能访问敏感的特征值。继续上面的例子，允许信任的设备获取会员邮件地址，可以像如下所示来完成功能：
    emailCharacteristic = [[CBMutableCharacteristic alloc]    initWithType:emailCharacteristicUUID    properties:CBCharacteristicPropertyRead    | CBCharacteristicPropertyNotifyEncryptionRequired    value:nil permissions:CBAttributePermissionsReadEncryptionRequired];</p>

<p>在这个例子中，特征被配置为允许信任的设备读和订阅它的值。<br/>
如果主机和外设是 iOS 设备，其他设备想要与它配对时，iOS 设备都会收到一个提示，主机设备的提示包含一个编码，你必须在外设端输入这个编码才能完成配对。<br/>
在配对完成后，外设认为配对的主机是可以信任的并允许主机访问它加密的特征值。</p>

<h1>译者结束语</h1>

<p>利用空余时间断断续续几天翻译完了，错误和遗漏之处在所难免，如果你愿意，可以通过 <a href="jjunjoegg@gmail.com">jjunjoegg@gmail.com</a> 告诉我，谢谢。后面计划实现一个蓝牙主机和外设的例子程序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[好的工具软件、XCode插件收藏(持续更新中)]]></title>
    <link href="http://jjunjoe.github.io/blog/2014/04/12/hao-de-ruan-jian-,-gong-ju-,-cha-jian-shou-cang/"/>
    <updated>2014-04-12T00:59:57+08:00</updated>
    <id>http://jjunjoe.github.io/blog/2014/04/12/hao-de-ruan-jian-,-gong-ju-,-cha-jian-shou-cang</id>
    <content type="html"><![CDATA[<h1>一、XCode 插件</h1>

<ol>
<li>Alcatraz: The package manager for Xcode<br/>
超强的 XCode 包管理器插件
<a href="http://alcatraz.io">http://alcatraz.io</a> 或者 <a href="https://github.com/supermarin/Alcatraz">https://github.com/supermarin/Alcatraz</a></li>
</ol>


<!--more-->


<ol>
<li><p>FuzzyAutocompletePlugin: A Xcode 5 plugin that adds more flexible autocompletion rather than just prefix-matching.<br/>
超强的 XCode 代码自动补全插件, 不仅仅是前缀匹配。
<a href="https://github.com/chendo/FuzzyAutocompletePlugin">https://github.com/chendo/FuzzyAutocompletePlugin</a></p></li>
<li><p>XToDo: 一个注释辅助插件, 可以把项目中的 TODO FIXME等注释列出来<br/>
<a href="http://imi.im/post/xtodo">http://imi.im/post/xtodo</a><br/>
<a href="https://github.com/trawor/XToDo">https://github.com/trawor/XToDo</a></p></li>
</ol>


<h1>二、工具软件</h1>

<ol>
<li>Charles: 网络封包分析工具.Charles比较方便的应用于iOS开发的场景包括：分析和服务器端的接口，模拟3g/2g网络，模拟高延迟网络，分析应用流量等。<br/>
大神唐巧介绍该工具的网址<br/>
<a href="http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles">http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles</a><br/>
官网：<br/>
<a href="http://www.charlesproxy.com">http://www.charlesproxy.com</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperation and NSOperationQueue]]></title>
    <link href="http://jjunjoe.github.io/blog/2014/03/02/nsoperation-and-nsoperationqueue/"/>
    <updated>2014-03-02T14:05:08+08:00</updated>
    <id>http://jjunjoe.github.io/blog/2014/03/02/nsoperation-and-nsoperationqueue</id>
    <content type="html"><![CDATA[<h1>一、Operation Obeject和 Operation Queue 概述</h1>

<h2>1、Operation Object 概述</h2>

<p>Operation Object 是 NSOperation 类的实例，封装了应用需要执行的任务和执行任务需要的数据。 NSOperation 本身是一个抽象基类，我们必须实现其子类。Foundation framework 提供了两个具体子类，可以直接使用：</p>

<!--more-->


<ol>
<li><strong><code>NSInvocationOperation</code></strong> <br/>
基于应用的一个对象和selector来创建Operation Object，比如用现有的方法来执行需要的任务可以使用NSInvocationOperation。</li>
<li><strong><code>NSBlockOperation</code></strong><br/>
用来并发的执行一个或多个block对象。</li>
</ol>


<p>除了上述 NSInvocationOperation 和 NSBlockOperation 两种 operation onject 可以直接使用之外，我们还可以自定义 Operation object。</p>

<h2>2、Operation Queue 概述</h2>

<p>Operation Queue 是 Cocoa 版本的并发dispatch queue， 由 NSOperationQueue 类实现，</p>

<h2>3、Operation 的优势</h2>

<ol>
<li>支持基于图的Operation Objects<code>依赖关系</code>，可以阻止某个 operation 运行，直到它依赖的所有 operation 都已经完成。</li>
<li>支持可选的 <code>completion block</code>，在 operation 的主任务完成后调用。</li>
<li>支持应用使用 <code>KVO</code> 通知来监控 operation 的执行状态。</li>
<li>支持 operation 的<code>优先级</code>。</li>
<li>支持<code>取消</code>，允许终止正在执行的任务。</li>
</ol>


<h2>4、并发和非并发 Operation</h2>

<p>可以将 Operation 添加到 operation queue 中来执行操作，也可以手动调用 start 方法来执行一个 operation object，但这样不保证 operation 会并发执行（由 operation 的 isConcurrent 属性决定，而 isConcurrent 默认是 NO，表示 operation 与调用线程同步执行）。<br/>
<strong>当提交非并发 operation 到 operation queue 时，queue 会创建线程来运行 operation，因此也能达到异步执行的目的。只有不希望用 operation queue 来执行 operation 时，才需要定义并发 operation。</strong></p>

<h1>二、Operation Obeject和 Operation Queue 使用</h1>

<h2>1、使用 Operation 同步运行任务</h2>

<h3>1) 下面例子显示了如何使用 NSInvocationOperation 和 NSBlockOperation 以及自定义的 Operation 同步运行任务</h3>

<p>源码文件清单如下（4个文件）：<br/>
<code>第1个文件：CountingOperation.h</code></p>

<pre><code>@interface CountingOperation : NSOperation
/* Designated Initializer */
- (instancetype) initWithStartingCount:(NSUInteger)paramStartingCount endingCount:(NSUInteger)paramEndingCount;
@end
</code></pre>

<p><code>第二个文件：CountingOperation.m</code></p>

<pre><code>#import "CountingOperation.h"

@interface CountingOperation ()
@property (nonatomic, unsafe_unretained) NSUInteger startingCount;
@property (nonatomic, unsafe_unretained) NSUInteger endingCount;
@property (nonatomic, unsafe_unretained, getter=isFinished) BOOL finished;
@property (nonatomic, unsafe_unretained, getter=isExecuting) BOOL executing;
@end

@implementation CountingOperation
- (instancetype) init {
    return([self initWithStartingCount:0
                           endingCount:1000]);
}

- (instancetype) initWithStartingCount:(NSUInteger)paramStartingCount
                           endingCount:(NSUInteger)paramEndingCount
{
    self = [super init];

    if (self != nil){

        /* Keep these values for the main method */
        _startingCount = paramStartingCount;
        _endingCount = paramEndingCount;
    }
    return(self);
}

- (void) main {
    @try {
        /* Here is our autorelease pool */
        @autoreleasepool {
            /* Keep a local variable here that must get set to YES
             whenever we are done with the task */
            BOOL taskIsFinished = NO;

            /* Create a while loop here that only exists
             if the taskIsFinished variable is set to YES or
             the operation has been cancelled */
            while (taskIsFinished == NO &amp;&amp; [self isCancelled] == NO){

                /* Perform the task here */
                NSLog(@"Main Thread = %@", [NSThread mainThread]);
                NSLog(@"Current Thread = %@", [NSThread currentThread]);
                NSUInteger counter = _startingCount;

                for (counter = _startingCount;
                     counter &lt; _endingCount;
                     counter++){
                    NSLog(@"Count = %lu", (unsigned long)counter);
                }
                /* Very important. This way we can get out of the
                 loop and we are still complying with the cancellation
                 rules of operations */
                taskIsFinished = YES;
            }

            /* KVO compliance. Generate the
             required KVO notifications */
            [self willChangeValueForKey:@"isFinished"];
            [self willChangeValueForKey:@"isExecuting"];
            _finished = YES;
            _executing = NO;
            [self didChangeValueForKey:@"isFinished"];
            [self didChangeValueForKey:@"isExecuting"];
        }
    }
    @catch (NSException * e) {
        NSLog(@"Exception %@", e);
    }
}
@end
</code></pre>

<p><code>第三个文件：AppDelegate.h</code></p>

<pre><code>@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;

@property (strong, nonatomic) UIWindow *window;

@property (nonatomic, strong) NSInvocationOperation *simpleInvocationOperation;
@property (nonatomic, strong) NSBlockOperation *simpleBlockOperation;

@end
</code></pre>

<p><code>第4个文件：AppDelegate.m</code></p>

<pre><code>#import "AppDelegate.h"

#import "CountingOperation.h"

@implementation AppDelegate

- (void) simpleOperationEntry:(id)paramObject{
    NSLog(@"Parameter Object = %@", paramObject);
    NSLog(@"Main Thread = %@", [NSThread mainThread]);
    NSLog(@"Current Thread = %@", [NSThread currentThread]);
}

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    NSNumber *simpleObject = [NSNumber numberWithInteger:123];
    self.simpleInvocationOperation = [[NSInvocationOperation alloc]
                                      initWithTarget:self
                                      selector:@selector(simpleOperationEntry:) object:simpleObject];
    [self.simpleInvocationOperation start];



    self.simpleBlockOperation = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"Main Thread = %@", [NSThread mainThread]);
        NSLog(@"Current Thread = %@", [NSThread currentThread]);
        NSUInteger counter = 0;
        for (counter = 0; counter &lt; 100;
             counter++){
            NSLog(@"Count = %lu", (unsigned long)counter);
        } }];

    /* Start the operation */
    [self.simpleBlockOperation start];

    /* Print something out just to test if we have to wait
     for the block to execute its code or not */
    NSLog(@"Main thread is here--after simpleBlockOperation");


    self.simpleCountingOperation = [[CountingOperation alloc]
                            initWithStartingCount:0
                            endingCount:100];
    [self.simpleCountingOperation start];
    NSLog(@"Main thread is here--after simpleCountingOperation");

    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    // Override point for customization after application launch.
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return YES;
}
</code></pre>

<p><code>输出结果如下：</code><br/>
2014-03-07 19:04:09.108 OperationSample[1497:70b] Parameter Object = 123<br/>
2014-03-07 19:04:09.111 OperationSample[1497:70b] Main Thread = &lt;NSThread: 0x8a43800>{name = (null), num = 1}<br/>
2014-03-07 19:04:09.112 OperationSample[1497:70b] Current Thread = &lt;NSThread: 0x8a43800>{name = (null), num = 1}<br/>
2014-03-07 19:04:09.113 OperationSample[1497:70b] Main Thread = &lt;NSThread: 0x8a43800>{name = (null), num = 1}<br/>
2014-03-07 19:04:09.114 OperationSample[1497:70b] Current Thread = &lt;NSThread: 0x8a43800>{name = (null), num = 1}<br/>
2014-03-07 19:04:09.115 OperationSample[1497:70b] Count = 0<br/>
2014-03-07 19:04:09.116 OperationSample[1497:70b] Count = 1<br/>
&hellip;&hellip;<br/>
2014-03-07 19:04:09.235 OperationSample[1497:70b] Count = 98<br/>
2014-03-07 19:04:09.236 OperationSample[1497:70b] Count = 99<br/>
2014-03-07 19:04:09.237 OperationSample[1497:70b] Main thread is here&ndash;after simpleBlockOperation<br/>
2014-03-07 19:04:09.239 OperationSample[1497:70b] Main Thread = &lt;NSThread: 0x8a43800>{name = (null), num = 1}<br/>
2014-03-07 19:04:09.240 OperationSample[1497:70b] Current Thread = &lt;NSThread: 0x8a43800>{name = (null), num = 1}<br/>
2014-03-07 19:04:09.241 OperationSample[1497:70b] Count = 0<br/>
2014-03-07 19:04:09.241 OperationSample[1497:70b] Count = 1<br/>
&hellip;&hellip;<br/>
2014-03-07 19:04:09.401 OperationSample[1497:70b] Count = 98<br/>
2014-03-07 19:04:09.402 OperationSample[1497:70b] Count = 99<br/>
2014-03-07 19:04:09.404 OperationSample[1497:70b] Main thread is here&ndash;after simpleCountingOperation</p>

<h3>2) 也可以继承 NSOperation 并在子类中执行同步任务，示例在上面。</h3>

<p>关于继承 NSOperation 需要注意的事情：</p>

<ol>
<li><strong>如果不打算使用 operation 队列,必须在 operation 的 start 方法中自己新建一个线程。<code>如果不想使用 operation 队列并且不想让你的 operation 与其他你手工 start 的 operation 进行异步操作，你可以简单的在 operation 的 start 方法里面调用 main 方法。</code></strong></li>
<li><strong>在你自己实现的 operation 中，NSOperation 实例有<code>两个重要的方法必须重载:isExecuting 和 isFinished</code>。他们可以被其它的任意对象调用。在这两个方法中,必须返回一个线程安全值,这个值可以在 operation 中进行操作。一旦你的 operation 开始了,必须通过 KVO 告诉所有的监听者,你改变了这这两个方法返回的值。</strong></li>
<li><strong>在 <code>operation 的 main 方法里面,必须提供 autorelease pool</code>,因为你的 operation 在未来的某个时刻会被 添加到一个 operation 队列中。你必须确保你的 operation 运行,这里有两种方法:手动启动 operation 或者通过 operation 队列启动。</strong></li>
<li><strong><code>必须为你的 operation 提供一个初始化方法。所有 operation 的其它初始化方法,包括默认的 init 方法,必须调用指定的初始化方法</code>,指定的初始化方法一般具有 多个参数。其它的初始化方法必须确保传递的任何参数符合指定的初始化方法。</strong></li>
</ol>


<h2>2、使用 Operation 异步运行任务</h2>

<p>我们希望 operations 运行在它们自己的线程中,而不是占用主线程的时间片，有两种方式异步运行任务：</p>

<ol>
<li>最好的解决方案是<code>使用 operation 队列</code>。</li>
<li>不过,如果你想手动管理 operations(不建议),可以<code>继承 NSOperation,并在 main 方法中新启一个线程</code>。</li>
</ol>


<p><strong><code>注意</code>： operation 队列可能会也可能不会立即通过 nvocation operation 的 start 方法启动 invocation operation。但是,需要牢记重要的一点:添加 operations 至 operation 队列后,你不能手动 启动 operations,必须交由 operation 队列负责。</strong></p>

<h3>1）下面的例子展示了将 NSInvocationOperation 加入 NSOperationQueue 的使用。</h3>

<p>源码清单如下：</p>

<p><code>AppDelegate.h:</code></p>

<pre><code>@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;

@property (strong, nonatomic) UIWindow *window;
@property (nonatomic, strong) NSOperationQueue *operationQueue;
@property (nonatomic, strong) NSInvocationOperation *firstOperation;
@property (nonatomic, strong) NSInvocationOperation *secondOperation;

@end
</code></pre>

<p><code>AppDelegate.m:</code></p>

<pre><code>#import "AppDelegate.h"

@implementation AppDelegate

- (void) firstOperationEntry:(id)paramObject{
    NSLog(@"%s", __FUNCTION__);
    NSLog(@"Parameter Object = %@", paramObject);
    NSLog(@"Main Thread = %@", [NSThread mainThread]);
    NSLog(@"Current Thread = %@", [NSThread currentThread]);
}
- (void) secondOperationEntry:(id)paramObject{
    NSLog(@"%s", __FUNCTION__);
    NSLog(@"Parameter Object = %@", paramObject);
    NSLog(@"Main Thread = %@", [NSThread mainThread]);
    NSLog(@"Current Thread = %@", [NSThread currentThread]);    } 

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    NSNumber *firstNumber = @111;
    NSNumber *secondNumber = @222;
    self.firstOperation =[[NSInvocationOperation alloc]
                          initWithTarget:self
                          selector:@selector(firstOperationEntry:) object:firstNumber];
    self.secondOperation = [[NSInvocationOperation alloc]
                            initWithTarget:self
                            selector:@selector(secondOperationEntry:) object:secondNumber];
    self.operationQueue = [[NSOperationQueue alloc] init];

    /* Add the operations to the queue */
    [self.operationQueue addOperation:self.firstOperation];
    [self.operationQueue addOperation:self.secondOperation];
    NSLog(@"Main thread is here");

    // Override point for customization after application launch.
    return YES;
}
</code></pre>

<p><code>输出结果如下：</code><br/>
2014-03-07 20:31:22.300 OperationAsyncSample[1961:3207] -[AppDelegate secondOperationEntry:]<br/>
2014-03-07 20:31:22.300 OperationAsyncSample[1961:1303] -[AppDelegate firstOperationEntry:]<br/>
2014-03-07 20:31:22.300 OperationAsyncSample[1961:70b] Main thread is here<br/>
2014-03-07 20:31:22.306 OperationAsyncSample[1961:1303] Parameter Object = 111<br/>
2014-03-07 20:31:22.305 OperationAsyncSample[1961:3207] Parameter Object = 222<br/>
2014-03-07 20:31:22.307 OperationAsyncSample[1961:3207] Main Thread = &lt;NSThread: 0x8a3fa30>{name = (null), num = 1}<br/>
2014-03-07 20:31:22.307 OperationAsyncSample[1961:1303] Main Thread = &lt;NSThread: 0x8a3fa30>{name = (null), num = 1}<br/>
2014-03-07 20:31:22.308 OperationAsyncSample[1961:3207] Current Thread = &lt;NSThread: 0x8d32180>{name = (null), num = 2}<br/>
2014-03-07 20:31:22.309 OperationAsyncSample[1961:1303] Current Thread = &lt;NSThread: 0x8b2f050>{name = (null), num = 3}</p>

<h3>2）下面的例子展示了将自定义的 Operation 加入 NSOperationQueue 的使用。</h3>

<p>如果我们子类化了一个 NSOperation 类,并且把这个子类的实例对象添加到了 operation 队列,我们需要做 稍微的改动。记住以下几点：</p>

<ol>
<li>由于把 NSOperation 的子类对象添加到一个 operation 队列中,该对象会异步运行。由此必须重载 NSOperation 的实例方法 isConcurrent,在该方法中返回 YES.</li>
<li>在 start 方法里面执行 main 任务之前,需要定期的调用 isCancelled 方法来检测该函数的返回值,以确定是退出 start 方法还是开始运行 operation。在这里,当 operation 添加到队列中后,operation 的 start 方法将会被 operation 队列调用,start 方法中,调用 isCanelled 方法确定 operation 是否被取消。如果 operation 被取消了,只需要从 start 方法中简单的返回即可。如果没被取消,会在 start 方法中调用 main 方法。</li>
<li>在 main task 实现部分中 override main 函数,main 函数将被 operation 执行。在这个函数里面确保分配和初始化 autorelease pool,并且在返回之前释放这个 pool。</li>
<li>重载 operation 的 isFinished 和 isExecuting 方法,这两个函数返回对应的 BOOL 值,代表 operation 是执行完毕还是在执行中。</li>
</ol>


<p>源码清单如下：<br/>
<code>SimpleOperation.h:</code></p>

<pre><code>@interface SimpleOperation : NSOperation
/* Designated Initializer */
- (instancetype) initWithObject:(NSObject *)paramObject;
@end
</code></pre>

<p><code>SimpleOperation.m:</code></p>

<pre><code>#import "SimpleOperation.h"

@interface SimpleOperation ()
@property (nonatomic, strong) NSObject *givenObject;
@property (nonatomic, unsafe_unretained, getter=isFinished) BOOL finished;
@property (nonatomic, unsafe_unretained, getter=isExecuting) BOOL executing;
@end


@implementation SimpleOperation
- (instancetype) init {
    return([self initWithObject:@123]);
    }
    - (instancetype) initWithObject:(NSObject *)paramObject{
    self = [super init];
    if (self != nil){
        /* Keep these values for the main method */
        _givenObject = paramObject;
    }
    return(self);
}

    - (void) main {

    @try {

        @autoreleasepool {
            /* Keep a local variable here that must get set to YES
             whenever we are done with the task */
            BOOL taskIsFinished = NO;

            /* Create a while loop here that only exists
             if the taskIsFinished variable is set to YES or
             the operation has been cancelled */
            while (taskIsFinished == NO &amp;&amp; [self isCancelled] == NO){

                /* Perform the task here */
                NSLog(@"%s", __FUNCTION__);
                NSLog(@"Parameter Object = %@", _givenObject);
                NSLog(@"Main Thread = %@", [NSThread mainThread]);
                NSLog(@"Current Thread = %@", [NSThread currentThread]);

                /* Very important. This way we can get out of the
                 loop and we are still complying with the cancellation
                 rules of operations */
                taskIsFinished = YES;
            }

            /* KVO compliance. Generate the
             required KVO notifications */
            [self willChangeValueForKey:@"isFinished"];
            [self willChangeValueForKey:@"isExecuting"];
            _finished = YES;
            _executing = NO;
            [self didChangeValueForKey:@"isFinished"];
            [self didChangeValueForKey:@"isExecuting"];
        }
    }
    @catch (NSException * e) {
        NSLog(@"Exception %@", e);
    }
    }
    - (BOOL) isConcurrent{
    return YES;
    }
@end
</code></pre>

<p><code>AppDelegate.h:</code></p>

<pre><code>@class SimpleOperation;
@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;

@property (strong, nonatomic) UIWindow *window;
@property (nonatomic, strong) NSOperationQueue *operationQueue;
@property (nonatomic, strong) SimpleOperation *firstOperation;
@property (nonatomic, strong) SimpleOperation *secondOperation;

@end
</code></pre>

<p><code>AppDelegate.m:</code></p>

<pre><code>#import "AppDelegate.h"
#import "SimpleOperation.h"

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    NSNumber *firstNumber = @111;
    NSNumber *secondNumber = @222;
    self.firstOperation = [[SimpleOperation alloc]
                           initWithObject:firstNumber];
    self.secondOperation = [[SimpleOperation alloc]
                            initWithObject:secondNumber];
    self.operationQueue = [[NSOperationQueue alloc] init];
    /* Add the operations to the queue */
    [self.operationQueue addOperation:self.firstOperation];
    [self.operationQueue addOperation:self.secondOperation];
    NSLog(@"Main thread is here");

    // Override point for customization after application launch.
    return YES;
}
</code></pre>

<p><code>输出结果如下：</code><br/>
2014-03-07 21:03:12.923 OperationAsyncSample[2053:320b] -[SimpleOperation main]<br/>
2014-03-07 21:03:12.923 OperationAsyncSample[2053:1303] -[SimpleOperation main]<br/>
2014-03-07 21:03:12.923 OperationAsyncSample[2053:70b] Main thread is here<br/>
2014-03-07 21:03:12.926 OperationAsyncSample[2053:1303] Parameter Object = 111<br/>
2014-03-07 21:03:12.926 OperationAsyncSample[2053:320b] Parameter Object = 222<br/>
2014-03-07 21:03:12.927 OperationAsyncSample[2053:1303] Main Thread = &lt;NSThread: 0x8c4d6e0>{name = (null), num = 1}<br/>
2014-03-07 21:03:12.927 OperationAsyncSample[2053:320b] Main Thread = &lt;NSThread: 0x8c4d6e0>{name = (null), num = 1}<br/>
2014-03-07 21:03:12.928 OperationAsyncSample[2053:1303] Current Thread = &lt;NSThread: 0x8c66b80>{name = (null), num = 2}<br/>
2014-03-07 21:03:12.928 OperationAsyncSample[2053:320b] Current Thread = &lt;NSThread: 0x8d7bba0>{name = (null), num = 3}</p>

<h3>3）下面的例子展示了 Operation 创建依赖的使用。</h3>

<p><code>源码清单如下：</code></p>

<pre><code>@interface AppDelegate ()
    @property (nonatomic, strong) NSInvocationOperation *firstOperation;
@property (nonatomic, strong) NSInvocationOperation *secondOperation;
@property (nonatomic, strong) NSOperationQueue *operationQueue;
    @end
    @implementation AppDelegate
    - (void) firstOperationEntry:(id)paramObject{
    NSLog(@"First Operation - Parameter Object = %@",
          paramObject);
    NSLog(@"First Operation - Main Thread = %@",
          [NSThread mainThread]);
    NSLog(@"First Operation - Current Thread = %@",
          [NSThread currentThread]);
}

    - (void) secondOperationEntry:(id)paramObject{
    NSLog(@"Second Operation - Parameter Object = %@",
          paramObject);
    NSLog(@"Second Operation - Main Thread = %@",
          [NSThread mainThread]);
    NSLog(@"Second Operation - Current Thread = %@",
          [NSThread currentThread]);
    }

    - (BOOL) application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{
    NSNumber *firstNumber = @111;
    NSNumber *secondNumber = @222;
    self.firstOperation = [[NSInvocationOperation alloc]
                           initWithTarget:self
                           selector:@selector(firstOperationEntry:) object:firstNumber];
    self.secondOperation = [[NSInvocationOperation alloc]
                            initWithTarget:self
                            selector:@selector(secondOperationEntry:) object:secondNumber];
    [self.firstOperation addDependency:self.secondOperation];
    self.operationQueue = [[NSOperationQueue alloc] init];

    /* Add the operations to the queue */
    [self.operationQueue addOperation:self.firstOperation];
    [self.operationQueue addOperation:self.secondOperation];
    NSLog(@"Main thread is here");

    self.window = [[UIWindow alloc] initWithFrame:
                   [[UIScreen mainScreen] bounds]];
    self.window.backgroundColor = [UIColor whiteColor]; [self.window makeKeyAndVisible];
    return YES;
    }
</code></pre>

<p><code>输出结果如下：</code><br/>
2014-03-07 21:14:30.362 OperationAsyncSample[2093:1303] Second Operation - Parameter Object = 222<br/>
2014-03-07 21:14:30.362 OperationAsyncSample[2093:70b] Main thread is here<br/>
2014-03-07 21:14:30.364 OperationAsyncSample[2093:1303] Second Operation - Main Thread = &lt;NSThread: 0x8d49760>{name = (null), num = 1}<br/>
2014-03-07 21:14:30.365 OperationAsyncSample[2093:1303] Second Operation - Current Thread = &lt;NSThread: 0x8a50fc0>{name = (null), num = 2}<br/>
2014-03-07 21:14:30.366 OperationAsyncSample[2093:3607] First Operation - Parameter Object = 111<br/>
2014-03-07 21:14:30.366 OperationAsyncSample[2093:3607] First Operation - Main Thread = &lt;NSThread: 0x8d49760>{name = (null), num = 1}<br/>
2014-03-07 21:14:30.367 OperationAsyncSample[2093:3607] First Operation - Current Thread = &lt;NSThread: 0x8b48d20>{name = (null), num = 3}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Toll-Free-Bridge]]></title>
    <link href="http://jjunjoe.github.io/blog/2014/02/13/toll-free-bridge/"/>
    <updated>2014-02-13T23:40:09+08:00</updated>
    <id>http://jjunjoe.github.io/blog/2014/02/13/toll-free-bridge</id>
    <content type="html"><![CDATA[<h1>一、Tool-Free-Bridge 概述</h1>

<p>Toll-free bridging（TFB）是一种允许Core Foundation framework 类和 Foundation framework类之间可以互换使用的机制。<br/>
Core Foundation framework 是用 C 实现的，Core Foundation framework 中得 CFRetain 和CFRelease 对应非ARC环境 Objective-C 的 retain 和 release。这两个框架的对象只有在创建方式上有很小的区别（即由哪个框架创建），创建之后就可以互换使用了。因为他们的转换是没有额外 CPU 开销的，所以称为Free Bridge。</p>

<!--more-->


<p>但是，编译器不能自动管理 Core Foundation 对象的生命周期，所以必须通过转换或者 Core Foundation 宏的方式来告诉编译器管理对象所有权。</p>

<p>引用苹果开发文档里面的描述如下：</p>

<blockquote><ol>
<li>__bridge transfers a pointer between Objective-C and Core Foundation with no transfer of ownership.</li>
<li>__bridge_retained or CFBridgingRetain casts an Objective-C pointer to a Core Foundation pointer and also transfers ownership to you.
You are responsible for calling CFRelease or a related function to relinquish ownership of the object.</li>
<li>__bridge_transfer or CFBridgingRelease moves a non-Objective-C pointer to Objective-C and also transfers ownership to ARC.</li>
</ol>
</blockquote>

<p>翻译如下：</p>

<ol>
<li><strong><code>__bridge</code></strong> 直接在 Objective-C 指针和 Core Foundation 指针之间转换，<code>不牵涉所有权</code>（即不影响引用计数）。</li>
<li><strong><code>__bridge_retained</code></strong> 或 <strong><code>CFBridgingRetain</code></strong> 将 <code>Objective-C 指针</code>转换为 <code>Core Foundation 指针</code>，然后传递所有权。这样转换的对象需要调用 <strong><code>CFRelease</code></strong> 或者相关函数来释放。</li>
<li><strong><code>__bridge_transfer</code></strong> 或 <strong><code>CFBridgingRelease</code></strong> 将<code>非 Objective-C 指针</code>转换为 <code>Objective-C 指针</code>并将所有权交给 ARC 管理。</li>
</ol>


<h1>二、Tool-Free-Bridge 示例</h1>

<h4>__bridge 使用示例：</h4>

<pre><code>id obj = [[NSObject alloc] init];
void *p = (__bridge void *)obj;
id o = (__bridge id)p;
</code></pre>

<h4>__bridge_retained 使用示例：</h4>

<p>ARC环境下的如下代码：</p>

<pre><code>void *p = 0;    {
    id obj = [[NSObject alloc] init];
    p = (__bridge_retained void *)obj;
}
NSLog(@"class=%@", [(__bridge id)p class]);
</code></pre>

<p>对应非ARC环境下得如下代码：</p>

<pre><code>/* non-ARC */ 
void *p = 0;
{
    id obj = [[NSObject alloc] init];
    /* [obj retainCount] -&gt; 1 */

    p = [obj retain];
    /* [obj retainCount] -&gt; 2 */

    [obj release];
    /* [obj retainCount] -&gt; 1 */
}

/*
[(id)p retainCount] -&gt; 1 * which means,
[obj retainCount] -&gt; 1
So, the object still exists.
*/
NSLog(@"class=%@", [(__bridge id)p class]);
</code></pre>

<h4>__bridge_transfer 使用示例：</h4>

<p>ARC 环境下如下代码：</p>

<pre><code>id obj = (__bridge_transfer id)p;
</code></pre>

<p>对应非 ARC 环境下如下代码：</p>

<pre><code>/* non-ARC */
id obj = (id)p;
[obj retain];
[(id)p release];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa 内存管理]]></title>
    <link href="http://jjunjoe.github.io/blog/2014/02/09/cocoa-nei-cun-guan-li/"/>
    <updated>2014-02-09T15:35:50+08:00</updated>
    <id>http://jjunjoe.github.io/blog/2014/02/09/cocoa-nei-cun-guan-li</id>
    <content type="html"><![CDATA[<h1>一、Cocoa 内存管理的正确思考方式</h1>

<p>内存管理是程序员必须掌握的基本技能，所以总结一下 Cocoa 内存管理。<br/>
说到 Cocoa 的内存管理，必须先知道<code>引用计数（Reference Counting）</code>这个概念。而引用计数又分为iOS5之前的手工管理（非ARC）和iOS5之后自动管理（ARC）的。<!--more--></p>

<h2>1、规则</h2>

<ol>
<li>自己生成的对象，自己所持有。</li>
<li>非自己生成的对象也能持有。</li>
<li>不再需要自己持象时释放。</li>
<li>非自己持有的对象无法释放。</li>
</ol>


<h2>2、对象操作与 Objective-C 方法的对应关系</h2>

<table>
<thead>
<tr>
<th style="text-align:left;">对象操作                                            </th>
<th style="text-align:left;"> Objective-C方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">生成并持有对象(Create and have ownership of it)  </td>
<td style="text-align:left;"> alloc/new/copy/mutableCopy</td>
</tr>
<tr>
<td style="text-align:left;">持有对象(Take ownership of it)                  </td>
<td style="text-align:left;"> retain        </td>
</tr>
<tr>
<td style="text-align:left;">释放对象(Relinquish it)                         </td>
<td style="text-align:left;">release</td>
</tr>
<tr>
<td style="text-align:left;">废弃对象(Dispose of it)                         </td>
<td style="text-align:left;">dealloc</td>
</tr>
</tbody>
</table>


<h2>3、详解 Cocoa 内存管理</h2>

<h3>1）自己生成的对象，自己所持有。</h3>

<pre><code>/*
You create an object and have ownership.
*/
id obj = [[NSObject alloc] init];

/*
Now, you have ownership of the object.
*/
</code></pre>

<h3>2）非自己生成的对象也能持有。</h3>

<pre><code>/*
Obtain an object without creating it yourself or having ownership
*/
id obj = [NSMutableArray array];

/*
The obtained object exists and you don’t have ownership of it.
*/
</code></pre>

<h3>3）不再需要自己持象时释放。</h3>

<pre><code>/*
You create an object and have ownership.
*/
id obj = [[NSObject alloc] init];

/*
Now you have ownership of the object.
*/
[obj release];

/*
The object is relinquished.
Though the variable obj has the pointer to the object,
you can’t access the object anymore.
*/
</code></pre>

<p>取得存在的对象，但自己不持有。主要用于方法返回对象。</p>

<pre><code>- (id)object
{
    id obj = [[NSObject alloc] init];


    /*
    At this moment, this method has ownership of the object. 
    */

    [obj autorelease];

    /*
    The object exists, and you don’t have ownership of it. 
    */
    return obj;
}
</code></pre>

<h3>4）非自己持有的对象无法释放。</h3>

<pre><code>/*
You create an object and have ownership. 
*/

id obj = [[NSObject alloc] init];

/*
Now you have ownership of the object. 
*/

[obj release];

/*
You relinquished the object, of which you don’t have ownership! 

The application will crash!
The applications will crash in these cases:
When you call the release method to an already-disposed-of object. 
When you access an already-disposed-of object.
*/
id obj1 = [obj0 object];
/*
The obtained object exists and you don’t have ownership of it. 
*/

[obj1 release];

/*
You relinquished the object of which you don’t have ownership!
The application will crash sooner or later. 
*/    
</code></pre>

<h1>二、ARC 规则</h1>

<h2>1、概述</h2>

<p>引用计数式内存管理的本质在ARC中并没有改变。就像<code>ARC</code>这个名表示的那样，ARC只是自动的帮助我们处理<code>引用计数</code>的相关部分。
下面的示例代码如果注释中有/* non-ARC */，说明是ARC无效的，没有该注释说明是ARC有效的。</p>

<h2>2、ARC所有权修饰符</h2>

<ul>
<li>__strong</li>
<li>__weak</li>
<li>__unsafe_unretained</li>
<li>__autoreleasing</li>
</ul>


<p><strong><code>__strong、__weak、__autoreleasing 保证附有这些修饰符的自动变量初始化为nil。</code></strong>
即：</p>

<pre><code>id __strong obj0;
id __weak obj1;
id __autoreleasing obj2;
</code></pre>

<p>等价于：</p>

<pre><code>id __strong obj0 = nil;
id __weak obj1 = nil;
id __autoreleasing obj2 = nil;
</code></pre>

<h4>a) __strong</h4>

<p><strong><code>__strong是默认修饰符。表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃，随着强引用的时效，引用的对象回随之释放。</code></strong></p>

<h5>Sample1</h5>

<p><strong><code>ARC有效</code></strong>时，下面的代码：</p>

<pre><code>id  obj = [[NSObject alloc] init];
</code></pre>

<p>与<strong><code>ARC有效</code></strong>时的如下代码相同：</p>

<pre><code>id __strong obj = [[NSObject alloc] init];
</code></pre>

<p>与<strong><code>ARC无效</code></strong>时的如下代码相同：</p>

<pre><code>/* non-ARC */
id obj = [[NSObject alloc] init];
</code></pre>

<h5>Sample2</h5>

<p><strong><code>ARC有效</code></strong>时，下面的代码：</p>

<pre><code>{
    id __strong obj = [[NSObject alloc] init];
}
</code></pre>

<p>与<strong><code>ARC无效</code></strong>时的如下代码相同：</p>

<pre><code>/* non-ARC */
{

    id obj = [[NSObject alloc] init];
    [obj release];
}
</code></pre>

<h4>b) __weak</h4>

<p><strong><code>__weak与__strong相反，提供对对象的弱引用，可以用来避免循环引用。</code></strong><br/>
<strong><code>__weak弱引用不能持有对象实例，所以在超出其变量作用域时，对象即被释放。</code></strong><br/>
<strong><code>在__weak持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且弱引用修饰的变量值被赋值为nil。</code></strong></p>

<h5>Sample1</h5>

<pre><code>id __weak obj1 = nil;
{
    id __strong obj0 = [[NSObject alloc] init];
    obj1 = obj0;
    NSLog(@"A: %@", obj1);
}

NSLog(@"B: %@", obj1);
</code></pre>

<p>结果如下:  A: &lt;NSObject: 0x753e180> <br/>
B: (null)</p>

<h4>c) __unsafe_unretained</h4>

<p><strong><code>__unsafe_unretained与__weak一样，但差别在于__unsafe_unretained持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效，但是弱引用修饰的变量值不会被赋值为nil。</code></strong><br/>
<strong><code>__unsafe_unretained是iOS4的应用中需要用的，庆幸的是现在应用基本都不要支持iOS4了</code></strong></p>

<h5>Sample1</h5>

<pre><code>id __weak obj1 = nil;
{
    id __strong obj0 = [[NSObject alloc] init];
    obj1 = obj0;
    NSLog(@"A: %@", obj1);
}

NSLog(@"B: %@", obj1);
</code></pre>

<p>结果如下:  A: &lt;NSObject: 0x753e180> <br/>
B: &lt;NSObject: 0x753e180></p>

<h4>d) __autoreleasing</h4>

<p>ARC有效时，autorelease功能是起作用的。</p>

<h5>__autoreleasing Sample1</h5>

<p><strong><code>ARC无效</code></strong>时的如下代码：</p>

<pre><code>/* non-ARC */
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init];
[obj autorelease];
[pool drain];
</code></pre>

<p>与<strong><code>ARC有效</code></strong>时的如下代码相同：
    @autoreleasepool {
        id __autoreleasing obj = [[NSObject alloc] init];
    }</p>

<h5>如下例子，因为<strong>作为方法的返回值，编译器会自动注册到autoreleasepool</strong>，所以不使用<code>__autorelease</code>修饰符也能使对象注册到autoreleasepool</h5>

<pre><code>+ (id) array {
    return [[NSMutableArray alloc] init]; 
}

+ (id) array {
    id obj = [[NSMutableArray alloc] init];
    return obj; 

}
</code></pre>

<h5><strong>访问__weak修饰的变量，必然要访问注册到autoreleasepool的对象</strong></h5>

<pre><code>id __weak obj1 = obj0; NSLog(@"class=%@", [obj1 class]);
</code></pre>

<p>与下面的代码相同：</p>

<pre><code>id __weak obj1 = obj0;
id __autoreleasing tmp = obj1;
NSLog(@"class=%@", [tmp class]);
</code></pre>

<h5>为什么访问__weak修饰的变量，必然要访问注册到autoreleasepool的对象？</h5>

<p><strong>因为__weak修饰符支持有对象的弱引用，而在访问对象的过程中，该对象可能被废弃。而把要访问的__weak修饰的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在</strong></p>

<h5><strong>id指针或者对象指针的指针在没有显式指定时会被附加上__autorelease修饰符</strong></h5>

<pre><code>id *obj;
NSObject **ob;
</code></pre>

<p>等价于：</p>

<pre><code>id __autorelease *obj;
NSObject * __autorelease *ob;
</code></pre>

<p>所以：</p>

<pre><code>- (BOOL) performOperationWithError:(NSError **)error;
</code></pre>

<p>等价于：</p>

<pre><code>- (BOOL) performOperationWithError:(NSError * __autoreleasing *)error;
</code></pre>

<p>其实现应该如下所示：</p>

<pre><code>- (BOOL) performOperationWithError:(NSError * __autoreleasing *)error {
    /* Error occurred. Set errorCode */

    *error = [[NSError alloc] initWithDomain :MyAppDomain code: errorCode userInfo: nil];
    return NO;
}
</code></pre>

<h5>赋值给对象指针时，所有权修饰符必须一致</h5>

<p>如：</p>

<pre><code>NSError *error = nil; 
NSError **pError = &amp;error;
</code></pre>

<p>编译器会报错：<br/>
error: initializing &lsquo;NSError <em>__autoreleasing </em>&rsquo; with an expressionof type &lsquo;NSError <em>__strong </em>&rsquo; changes retain/release properties of pointerNSError **pError = &error;    下面是正确的形式：</p>

<pre><code>NSError *error = nil;
NSError * __strong *pError = &amp;error; 
/* No compile error */
</code></pre>

<p>其他修饰符也是：</p>

<pre><code>NSError __weak *error = nil;
NSError * __weak *pError = &amp;error; 
/* No compile error */

NSError __unsafe_unretained *unsafeError = nil;
NSError * __unsafe_unretained *pUnsafeError = &amp;unsafeError;
/* No compile error */
</code></pre>

<h5>虽然可以非显示的指定__autorelease修饰符，但也可以显式指定，不过显式指定时，对象变量要位自动变量（包括局部变量、函数、方法参数等）</h5>

<h2>3、ARC 详细规则</h2>

<ol>
<li><strong>不能使用retain, release, retainCount, and autorelease.</strong>2. <strong>不能使用NSAllocateObject and NSDeallocateObject.</strong></li>
<li><strong>必须遵守内存管理的方法命名规则.</strong></li>
<li><strong>不要显式调用dealloc.</strong></li>
<li><strong>使用 @autoreleasepool 代替 NSAutoreleasePool.</strong></li>
<li><strong>不能使用区域（NSZone）.</strong></li>
<li><strong>对象类型变量不能作为C语言结构体或者联合(struct/union)的成员.</strong></li>
<li><strong>显式转换"id"和"void *&ldquo;.</strong></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block and GCD]]></title>
    <link href="http://jjunjoe.github.io/blog/2014/02/02/block-and-gcd/"/>
    <updated>2014-02-02T23:16:05+08:00</updated>
    <id>http://jjunjoe.github.io/blog/2014/02/02/block-and-gcd</id>
    <content type="html"><![CDATA[<h1>1、block、GCD概述</h1>

<h2>Blocks</h2>

<p>通常代表一个很小、自包的代码片段。其目的是支持多核并行编程。
Blocks 作为传统回调函数的一个实用的替代办法,有以下两个原因:<br/>
1. 它们可以让你在调用的地方编写代码实现后面将要执行的操作。因此 Blocks 通常作为框架方法的参数。  2. 它们允许你访问局部变量，而不是需要使用一个你想要执行操作时集成所有上下文的信息的数据结构来进行回调,你可以直接简单的访问局部变量。<!--more--></p>

<h2>GCD(Grand Central Dispatch):</h2>

<p>GCD是一套低层API，提供了一种新的方法来进行并发程序编写。GCD和NSOperationQueue都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。但GCD比之NSOpertionQueue更底层更高效，它是C级别的框架，不是Cocoa框架的一部分。</p>

<p>GCD拥有非常轻量级的工作单元和并发方式，并且由系统决定其最佳调度方式，所以GCD比手工实现线程更加高效。<br/>
但GCD相对自定义原始线程还是有一个缺点：加入队列的任务什么时候开始是由系统决定的，不像原始线程能迅速启动。
本文主要用来总结一下对 block 和 GCD 的基本使用，所以不会特别详细，也不会特别深入，不会涉及block的实现什么的，主要是让自己以后能快速参考拿来使用。</p>

<h1>2、block</h1>

<h2>block Object</h2>

<p>block object有时被称作闭包。构建 Block Objects 和构建传统的 C 函数类似。Block Objects 可 以有返回值,可以接受参数。BlockObjects 可以内联定义,或者当做一个独立的代码块来看待,这一点与 C 函数相同。</p>

<h2>1）block声明</h2>

<p>与C语言的函数指针很类似，将 * 号替换为 ^ 就可以了。
举例如下：</p>

<pre><code>void (^blockReturningVoidWithVoidArgument)(void);

int (^blockReturningIntWithIntAndCharArguments)(int, char);
￼￼void (^arrayOfTenBlocksReturningVoidWithIntArgument[10])(int);
</code></pre>

<p>一个没有使用任何参数的 block 必须在参数列表 上面用 void 标明。</p>

<p>在多个地方使用同一个给定的签名的 block 时，typedef可以方便block使用。
举例如下：</p>

<pre><code>typedef float (^MyBlockType)(float, float);
MyBlockType myFirstBlock = // ... ;
MyBlockType mySecondBlock = // ... ;
</code></pre>

<h2>2）block的创建和调用</h2>

<h3>创建block：</h3>

<pre><code>void (^blockReturningVoidWithVoidArgument)(void) =
^(void){
    NSLog(@"Hello, World");
};
</code></pre>

<h3>调用block很简单：</h3>

<pre><code>blockReturningVoidWithVoidArgument();
</code></pre>

<p>如下方式创建和调用也可以：</p>

<pre><code>void (^blockReturningVoidWithVoidArgument)(void) = 0;
blockReturningVoidWithVoidArgument = ^(void){
    NSLog(@"Hello, World");
};
blockReturningVoidWithVoidArgument();
</code></pre>

<h3>block数组创建和调用</h3>

<p>举例如下：</p>

<pre><code>void (^blockReturningVoidWithVoidArgument[2])(void) = 0;
blockReturningVoidWithVoidArgument = {
    ^(void){NSLog(@"Hello, World 1");},
    ^(void){NSLog(@"Hello, World 2");}
};
blockReturningVoidWithVoidArgument[0]();
blockReturningVoidWithVoidArgument[1]();
</code></pre>

<h3>block 作为函数使用</h3>

<pre><code>￼ int (^oneFrom)(int) = ^(int anInt) {
    return anInt - 1;
};

printf("1 from 10 is %d", oneFrom(10));￼
// Prints "1 from 10 is 9"
</code></pre>

<h3>block 作为参数使用</h3>

<p>把 block 作为参数传递给一个函数或方法。需要创建一个”内联(inline)”的 block。<br/>
下面的例子确定一个 NSSet 是否包含一个由局部变量指定的单词,并且如果条件 成立把另外一个局部变量(found)设置为 YES(并停止搜索)：</p>

<pre><code>__block BOOL found = NO;

NSSet *aSet = [NSSet setWithObjects: @"Alpha", @"Beta", @"Gamma", @"X", nil];

NSString *string = @"gamma";

[aSet enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {

    if ([obj localizedCaseInsensitiveCompare:string] == NSOrderedSame) {

        *stop = YES;

        found = YES;
    }

}];

// At this point, found == YES
</code></pre>

<h3>拷贝Blocks</h3>

<p>   通常,你不需要 copy(或 retain)一个 block.在你希望 block 在它被声明的作用域 被销毁后继续使用的话,你子需要做一份拷贝。拷贝会把 block 移到堆里面。你可以使用 C 函数来 copy 和 release 一个 block</p>

<p>引用《Pro Multithreading and Memory Management for iOS and OS X》的描述：</p>

<blockquote><p>you can use &ldquo;Block_copy&rdquo; and &ldquo;Block_release&rdquo; functions, instead of “copy” and “release” methods in Objective-C. The concept of the reference count and how to use it are just same as the copy and release methods.    void (^blk_on_heap)(void) = Block_copy(blk_on_stack);   Block_release(blk_on_heap);</p></blockquote>

<h2>3) block和变量</h2>

<p>这一小节有点复杂，但是是必须掌握。<br/>
block内访问变量跟函数内访问变量很相似，但不完全一样，注意下面的列表中描述。<br/>
我们在block里面能遇到哪些变量呢？总结如下：</p>

<ol>
<li><strong>全局变量（包括静态局部变量）、全局函数（这个严格来说不算变量，也归在这一起吧）</strong>：<br/>
block内能访问，并且能修改这些变量，与函数范围内使用全局变量一样。block内能访问全局函数。</li>
<li><strong>与block同一作用域范围内的局部变量</strong>：<br/>
只能读取，不能修改。与函数不一样，函数是无法访问函数调用所在的代码同一作用域的其他变量的。</li>
<li><strong>与block同一作用域范围内的__block变量</strong>：<br/>
能读取，能修改。与函数不一样，函数没有__block类型变量</li>
<li><strong>传递给block的</strong>：<br/>
跟函数的参数一样，该怎么用就怎么用。</li>
<li><strong>block内部的变量</strong>：<br/>
该怎么用就怎么用。</li>
</ol>


<p><strong><em>注意</em></strong>：上面所说的<strong>与block同一作用域范围</strong>，指的是block所在的代码范围，比如在方法testVariablesForBlock中使用的block，那么这个范围指的是testVariablesForBlock的代码范围内，不是指block本身包含的代码范围内。</p>

<p>好吧，还是举例说明一下，详细解释看代码注释：</p>

<pre><code>int Global = 100;
int static StaticGlobal = 100;
void globalFunc(){
    NSLog(@"Hello globalFunc");
}
- (void)testVariablesForBlock
{
    __block int blockLocal  = 100;
    static int staticLocal  = 100;
    int local = 100;    
    int i = 100;

    void (^blockSample)(int) = ^(int value){

        int inBlock = 100;

        NSLog(@"Before modified, Global:%d, StaticGlobal:%d, blockLocal:%d, staticLocal:%d, local:%d, i:%d",
          Global, StaticGlobal, blockLocal, staticLocal, local, value);
        // 输出：Before modified, Global:100, StaticGlobal:100, blockLocal:100, staticLocal:100, local:100, i:100

        Global++;       // 全局变量，可以修改
        StaticGlobal++; // 静态全局变量，可以修改
        blockLocal++;   // __block变量，可以修改
        staticLocal++;  // 静态局部变量，可以修改
        //local++;      // 局部变量，只能读取，不能修改。此处语法错
        value++;        // 参数，跟函数传参一样，传进来是参数的副本
        inBlock++;      // block里面的变量，随便怎么用

        globalFunc();   // 全局函数，可以调用
        // 输出：Hello globalFunc
    };

    blockSample(i);

    NSLog(@"After modified, Global:%d, StaticGlobal:%d, blockLocal:%d, staticLocal:%d, local:%d, i:%d",
      Global, StaticGlobal, blockLocal, staticLocal, local, i);
    // 输出：After modified, Global:101, StaticGlobal:101, blockLocal:101, staticLocal:101, local:100, i:100
}
</code></pre>

<h2>4) block递归</h2>

<p>block递归需要用到static block或者__block block：</p>

<pre><code>- (void)testRecursionForBlock
{
    /*
    用 static block 或 __block block 实现 block 递归
    */

    // 1 static block
    static void (^ const staticBlock)(int) = ^(int i) {
        if (i &gt; 0) {
            NSLog(@" &gt;&gt; static block %d", i);
            staticBlock(i - 1);
        }
    };
    staticBlock(5);
    /* 输出：
    &gt;&gt; static block 5
    &gt;&gt; static block 4
    &gt;&gt; static block 3
    &gt;&gt; static block 2
    &gt;&gt; static block 1
    */

    // 2 __block block
    __block void (^blockBlock)(int);
    blockBlock = ^(int i) {
        if (i &gt; 0) {
            NSLog(@" &gt;&gt; block block %d", i);
            blockBlock(i - 1);
        }
    };
    blockBlock(5);
    /* 输出：
    &gt;&gt; block block 5
    &gt;&gt; block block 4
    &gt;&gt; block block 3
    &gt;&gt; block block 2
    &gt;&gt; block block 1
    */
}
</code></pre>

<h2>5）block的生命周期</h2>

<p>需要注意的是，block是分配在stack栈空间的，所以如下代码示例是错误的：</p>

<pre><code>- (void)testLifeCycleForBlock
{
    /*
    block 是分配在 stack 上的
    如下的做法 stack 分配的 block 在 if 或 else 内是有效的，但是到大括号 } 退出时就可能无效了
    跟野指针一样危险
    */

    dispatch_block_t blockSample;
    BOOL x = YES;

    if (x) {
        blockSample = ^{ printf("true\n"); };
    } else {
        blockSample = ^{ printf("false\n"); };
    }
    blockSample();  // 已失效
}
</code></pre>

<h1>3、GCD</h1>

<h2>1）Dispatch Queue</h2>

<h3>a）dispatch queue类型</h3>

<p>GCD中有两种类型的dispatch queue：</p>

<ol>
<li>Serial Dispatch Queue
串行队列，添加到该类型队列的任务是串行执行的。</li>
<li>Concurrent Dispatch Queue
并发队列，添加到该类型队列的任务是并发执行的。</li>
</ol>


<h3>b）dispatch queue获取</h3>

<p>我们可以获取如下dispatch queue：</p>

<h4>Main Queue 主队列</h4>

<p>主队列是<strong>串行队列</strong>，主队列中的任务都在主线程中执行，所以UI相关的代码都应该在该队列中执行。<br/>
dispatch_get_main_queue 能获取到主队列。<br/>
使用示例：</p>

<pre><code>// How to get the main dispatch queue   
dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();
</code></pre>

<h4>Global Queues 全局队列</h4>

<p>全局队列是<strong>并发队列</strong>，并由整个进程共享。进程中存在高、中（默认）、低、后台四个优先级全局队列。<br/>
dispatch_get_global_queue 能获取到全局队列。  <br/>
使用示例：</p>

<pre><code>// How to get a global dispatch queue of high priority
dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);

// How to get a global dispatch queue of default priority
dispatch_queue_t globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

// How to get a global dispatch queue of low priority
dispatch_queue_t globalDispatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);


// How to get a global dispatch queue of background priority
dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
</code></pre>

<h4>自定义 Queue</h4>

<p>这是用户创建的queue，所以我称它为自定义queue。该类型的dispatch queue是并发还是串行由创建者决定。<br/>
  dispatch_queue_t dispatch_queue_create(
   const char *label
   dispatch_queue_attr_t attr) 能创建自定义队列。<br/>
参数attr如果是<strong>DISPATCH_QUEUE_SERIAL</strong> (or NULL) 则创建<strong>串行队列</strong>；如果是 <strong>DISPATCH_QUEUE_CONCURRENT</strong> 则创建<strong>并发队列</strong>。</p>

<p>自定义串行队列使用示例：</p>

<pre><code>dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create("com.example.gcd.MySerialDispatchQueue", NULL);
</code></pre>

<p>自定义并发队列使用示例：</p>

<pre><code>dispatch_queue_t myConcurrentDispatchQueue = dispatch_queue_create( "com.example.gcd.MyConcurrentDispatchQueue", DISPATCH_QUEUE_CONCURRENT);
dispatch_async(myConcurrentDispatchQueue, ^{NSLog(@"block on myConcurrentDispatchQueue");});
dispatch_release(myConcurrentDispatchQueue);
</code></pre>

<p><strong><em>注意</em></strong>：自定义的queue需要自己释放。</p>

<h3>c）dispatch queue 的控制</h3>

<p>所谓的控制，无非就是如何使用GCD的API，所以下面挨个来。</p>

<h4>dispatch_set_target_queue</h4>

<p>从字面意思可以知道，dispatch_set_target_queue 使用来设置queue的，其实它主要用于自定义queue的优先级设定。新创建的自定义queue的优先级类似Global Queue的默认优先级，可以按下面的示例代码来修改</p>

<pre><code>dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create("com.example.gcd.MySerialDispatchQueue", NULL);

dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);

dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);
</code></pre>

<h4>dispatch_after设定一个定时，多久之后再将任务推入队列。  <strong><em>注意</em></strong>：是多久之后推入队列并不代表多久之后任务开始执行。</h4>

<pre><code>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);
dispatch_after(time, dispatch_get_main_queue(), ^{
    NSLog(@"waited at least three seconds."); });
</code></pre>

<h4>dispatch group</h4>

<p>我们可以将完成一组相关任务的 block 添加到一个 dispatch group 中去，这样可以在 group 中所有 block 任务都完成之后，再做其他事情。</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, queue, ^{NSLog(@"blk0");});
dispatch_group_async(group, queue, ^{NSLog(@"blk1");});
dispatch_group_async(group, queue, ^{NSLog(@"blk2");});

dispatch_group_notify(group, dispatch_get_main_queue(), ^{NSLog(@"done");});
dispatch_release(group);
</code></pre>

<p>结果可能如下, 因为使用了global queue，所以blk0, blk1, blk2的先后顺序是随机的:  blk1  blk2  blk0  done</p>

<h4>dispatch wait上面的例子使用dispatch_group_notify来等待group中的任务完成后再启动一个block任务，也可以只简单的等待group完成任务，如下：</h4>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, queue, ^{NSLog(@"blk0");});
dispatch_group_async(group, queue, ^{NSLog(@"blk1");});
dispatch_group_async(group, queue, ^{NSLog(@"blk2");});

dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
</code></pre>

<h4>dispatch_barrier_async</h4>

<p>这个主要用于并发过程控制，比如读写文件时，对于读操作，可以多个读并行，但对于写操作，必须互斥，并且写操作没有完成时，读操作不允许执行，否则可能读入的就是脏数据，甚至程序会崩溃。这个功能可以用group和dispatch_set_target_queue实现，但相当复杂。GCD提供了更好的实现方式，就是dispatch_barrier_async。
下面先看下初步的读写操作控制，如下面的示例：</p>

<pre><code>dispatch_queue_t queue = dispatch_queue_create( "com.example.gcd.ForBarrier", DISPATCH_QUEUE_CONCURRENT);

dispatch_async(queue, blk0_for_reading);
dispatch_async(queue, blk1_for_reading);

/*
Writing data
From now on, all the tasks should read the updated data.
如果我们仅仅如下面这行代码这所示想实现写功能，是有问题的。
无法保证写的过程中阻止读
*/
dispatch_async(queue, blk_for_writing);

dispatch_async(queue, blk2_for_reading);
dispatch_async(queue, blk3_for_reading);

dispatch_release(queue);
</code></pre>

<p>用dispatch_barrier_async就能完美的解决该问题，如下面的示例：</p>

<pre><code>dispatch_queue_t queue = dispatch_queue_create( "com.example.gcd.ForBarrier", DISPATCH_QUEUE_CONCURRENT);

dispatch_async(queue, blk0_for_reading);
dispatch_async(queue, blk1_for_reading);
/*  写操作blk_for_writing将在blk0_for_reading，blk1_for_reading
完成之后进行，并且此时只允许写操作，阻止其他读操作，直到写操作完成
*/
dispatch_barrier_async(queue, blk_for_writing);

dispatch_async(queue, blk2_for_reading);
dispatch_async(queue, blk3_for_reading);
dispatch_release(queue);
</code></pre>

<h4>dispatch_sync</h4>

<p>dispatch_sync将block任务加入给定的queue并等待任务执行结束才会返回。<br/>
例如：</p>

<pre><code>// right example1
dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  
dispatch_sync(queue1, ^{/* a task */NSLog(@"Hello?");});
</code></pre>

<p>再例如：</p>

<pre><code>// right example2
dispatch_queue_t queue2 = dispatch_queue_create("com.example.gcd.MySerialDispatchQueue2", NULL);  
dispatch_sync(queue2, ^{NSLog(@"Hello?");});
</code></pre>

<p>对于dispatch_sync需要特别注意，引用苹果官方文档如下：</p>

<blockquote><p><strong><em>You should never call the dispatch_sync or dispatch_sync_f function from a task that is executing in the same queue that you are planning to pass to the function. This is particularly important for serial queues, which are guaranteed to deadlock, but should also be avoided for concurrent queues.</em></strong></p></blockquote>

<p>归结起来其实就是一句话：<br/>
<strong><em>不要在当前队列中调用dispatch_sync 或 dispatch_sync_f，对于串行queue（包括main queue），这将必然导致死锁；在并发queue中也应该避免这么做。</em></strong></p>

<p>下面是验证上面结论的代码示例：</p>

<pre><code>// deadlock example3
// 如果当前队列是main queue，必然死锁
dispatch_queue_t queue3 = dispatch_get_main_queue();
dispatch_sync(queue3, ^{NSLog(@"Hello?");});

// deadlock example4
// 不管当前队列是什么队列，必然死锁
dispatch_queue_t queue4 = dispatch_get_main_queue();
dispatch_async(queue4, ^{
    dispatch_sync(queue4, ^{NSLog(@"Hello?");}); });

// deadlock example5
// 不管当前队列是什么队列，必然死锁
dispatch_queue_t queue5 = dispatch_queue_create("com.example.gcd.MySerialDispatchQueue5", NULL);
dispatch_async(queue5, ^{
    dispatch_sync(queue5, ^{NSLog(@"Hello?");}); });

// 最简单的死锁示例，不过dispatch_get_current_queue只用于调试目的，且在iOS 6中被弃用了
dispatch_sync(dispatch_get_current_queue(), ^{NSLog(@"Hello?");});
</code></pre>

<h4>dispatch_apply</h4>

<p>dispatch_apply调用单一block多次，并平行运算，然后等待所有运算结束。这个很NB，看下面的例子：</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(10, queue, ^(size_t index) {
    NSLog(@"%zu", index); });
NSLog(@"done");
</code></pre>

<p>输出结果可能如下：  4  1  0  3  5  2  6  8  9  7  done<br/>
再举个例子，假如我们有一个数组，要对数组的每个元素进行操作，然后将操作结果通知界面，大概的实现代码如下：
    dispatch_queue_t queue =    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    NSArray <em>array = [NSArray array];
    /</em>  Executing on a global dispatch queue asynchronously <em>/  dispatch_async(queue, ^{
        /</em>
        On the global dispatch queue, dispatch_apply function waitsfor all the tasks to be finished.
        */
        dispatch_apply([array count], queue, ^(size_t index) {</p>

<pre><code>        /*
        do something concurrently with all the objects in the NSArray object
        */
        NSLog(@"%zu: %@", index, [array objectAtIndex:index]);
    });

    /*
    All the tasks by dispatch_apply function are finished.
    */

    /*
    Execute on the main dispatch queue asynchronously
    */
    dispatch_async(dispatch_get_main_queue(), ^{
        /*
        Executed on the main dispatch queue.
        Something like updating userface, etc.
        */
        NSLog(@"done");
    });
});
</code></pre>

<h4>dispatch_suspend/dispatch_resume</h4>

<p>挂起和调度queue</p>

<pre><code>// dispatch_suspend function:
dispatch_suspend(queue);

// It can be resumed by the dispatch_resume function:
dispatch_resume(queue);
</code></pre>

<h4>Dispatch Semaphore</h4>

<p>跟别的操作系统的信号量一个原理，用于生产者-消费者模式，等到足够的资源了就发信号，等到信号的就可以消费了。</p>

<pre><code>- (void)testBlockForSemaphore{

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    /*
    Create a dispatch semaphore
    Set the initial value 1 for the counter of the dispatch semaphore
    to assure that only one thread will access the object of
    NSMutableArray class at the same time.
    */
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
    NSMutableArray *array = [[NSMutableArray alloc] init];
    for (int i = 0; i &lt; 100000; ++i) {
        dispatch_async(queue, ^{
            /*
            Wait for the dispatch semaphore
            Wait forever until the counter of the dispatch semaphore is one and more.
            */
            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

            /*
            Because the counter of the dispatch semaphore is one and more,
            the counter is decreased by one and the program flow has returned from
            the dispatch_semaphore_wait function.
            The counter of the dispatch semaphore is always zero here.
            Because only one thread can access the object of the NSMutableArray
            at the same time, you can update the object safely.
            */
            [array addObject:[NSNumber numberWithInt:i]];

            /*
            Because a task that needs concurrenct control is done,
            you have to call the dispatch_semaphore_signal function
            to increase the counter of the dispatch semaphore.

            If some threads are waiting for the counter of the dispatch_semaphore
            incremented on dispatch_semaphore_wait, the first thread will be started
            */
            dispatch_semaphore_signal(semaphore);
        });
    }
    NSLog(@"array:%@", array);

    /*
    Originally, because the dispatch semaphore isn’t needed any more,
    you have to release the dispatch semaphore.

    dispatch_release(semaphore);
    */
}
</code></pre>

<h4>dispatch_once</h4>

<p>dispatch_onch确保指定的任务在应用的生命周期内只执行一次。
下面是示例：</p>

<pre><code>static dispatch_once_t pred; dispatch_once(&amp;pred, ^{
    /*
    Initializing
    */
});
</code></pre>

<h4>Dispatch I/O</h4>

<p>在加载很大的文件的时候，你可能希望像下面的代码所描述的那样在全局并发队列中使用多个block并发的加载文件的不同部分。</p>

<pre><code>dispatch_async(queue, ^{/* loading the file from between 0 to 8191 byte.     */});
dispatch_async(queue, ^{/* loading the file from between 8192 to 16383 byte  */});
dispatch_async(queue, ^{/* loading the file from between 16384 to 24575 byte */});
dispatch_async(queue, ^{/* loading the file from between 24576 to 32767 byte */});
dispatch_async(queue, ^{/* loading the file from between 32768 to 40959 byte */});
dispatch_async(queue, ^{/* loading the file from between 40960 to 49151 byte */});
dispatch_async(queue, ^{/* loading the file from between 49152 to 57343 byte */});
dispatch_async(queue, ^{/* loading the file from between 57344 to 65535 byte */});
</code></pre>

<p>Dispatch I/O 可以让你梦想成真，下面是从stackoverflow上找的一个例子：</p>

<pre><code>- (void)testDispatchIO{

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    int intbuffer[] = { 1, 2, 3, 4 };
    dispatch_data_t data = dispatch_data_create(intbuffer, 4 * sizeof(int), queue, NULL);

    dispatch_semaphore_t sem = dispatch_semaphore_create(0);
    // Write
    dispatch_fd_t fd = open("/tmp/data.dat", O_RDWR | O_CREAT | O_TRUNC, S_IRWXU | S_IRWXG | S_IRWXO);

    printf("FD: %d\n", fd);

    dispatch_write(fd, data, queue,^(dispatch_data_t d, int e) {
        printf("Written %zu bytes!\n", dispatch_data_get_size(data) - (d ? dispatch_data_get_size(d) : 0));
        printf("\tError: %d\n", e);
        dispatch_semaphore_signal(sem);
    });

    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);

    close(fd);

    // Read
    fd = open("/tmp/data.dat", O_RDWR);

    dispatch_read(fd, 4 * sizeof(int), queue, ^(dispatch_data_t d, int e) {
        printf("Read %zu bytes!\n", dispatch_data_get_size(d));
        printf("\tError: %d\n", e);
        dispatch_semaphore_signal(sem);
    });

    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
    close(fd);

    // Exit confirmation
    getchar();

}
</code></pre>

<h4>更多方法可以访问</h4>

<p><a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html">Grand Central Dispatch (GCD) Reference</a></p>

<h2>2）dispatch source</h2>

<h3>a）dispatch source概述</h3>

<p>dispatch source 是基础数据类型，协调特定底层系统事件的处理。GCD支持以下dispatch source：</p>

<ul>
<li>Timer dispatch source:定时器通知</li>
<li>Singnal dispatch source:UNIX信号到达时通知</li>
<li>Descriptor dispatch source:各种文件和socket操作通知</li>
<li>Process dispatch source:进程相关的事件通知</li>
<li>Mach port dispatch source::Mach相关事件通知</li>
<li>Custom dispatch source:自定义触发的通知</li>
</ul>


<p>dispatch source替代了异步回调函数来处理系统相关的事件。当配置一个dispatch source时，需指定要检测的事件、dispatch queue、以及处理事件的代码（block或者函数）。当事件发生时，dispatch source 会提交你 block 或者函数到指定的queue执行。</p>

<p>和手工提交到queue的任务不同，dispatch source 为应用提供连续的事件源，除非显式的取消，dispatch source 会一直保留与dispatch queue 的关联。只要相应的事件发生，就会提交关联的代码到dispatch queue 去执行。</p>

<p>为了防止事件积压到dispatch queue，dispatch source实现了事件合并机制。如果新事件在上一个事件处理器出列病执行之前到达，dispatch source 会讲新旧事件的数据合并。根据事件类型的不同，合并操作可能会替换旧事件，或者更旧事件的信息。</p>

<p>未完，待续&hellip;&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello, Welcome to Joe's Home]]></title>
    <link href="http://jjunjoe.github.io/blog/2014/01/31/hello/"/>
    <updated>2014-01-31T15:24:48+08:00</updated>
    <id>http://jjunjoe.github.io/blog/2014/01/31/hello</id>
    <content type="html"><![CDATA[<p>今天是2014年，马年的农历大年初一，祝大家新年快乐，马上想啥有啥。这是我在github搭建的免费个人博客。<!--more-->由于今天才接触使用Octopress在github上搭建个人博客，所以仅仅是把环境搭建好了，可以从这篇博客看出来，现在我连基本的markdown语法都还不清楚，实际上我还是首次接触markdown，还有git等都很陌生（作为一名程序猿，连git都很陌生让我很惭愧，不过知耻而后勇）。所以，这些都是今后要学习和熟悉的。
建这个博客是想将自己关于技术和生活的一些文字归档，所以要坚持下去，这不，开始啦。</p>
]]></content>
  </entry>
  
</feed>
